# -*- coding: utf-8 -*-
"""SFE_06_4_kSweep.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1h7Tgfg-uqN9prDnPmJ0vuR0Cc7Md-M1D

# SFE-06.4 — k-Sweep Manifold Mapping · Topology of the Transition

This is a **mapping experiment**, not a detection experiment.

SFE-06.3 confirmed two known points in the joint observer manifold:
- `k=0.0` → **VOLUMETRIC** — eigenvalues [0.41, 0.39, 0.20]
- `k=1.0` → **PLANAR/LINEAR** — eigenvalues [0.70, 0.27, 0.04]

SFE-06.4 sweeps `k ∈ {0.0, 0.1, 0.2, 0.3, 0.5, 0.7, 1.0, 1.5, 2.0, 3.0, 5.0}` and maps the full manifold surface between them.

**Run cells top to bottom. Five interactive figures are produced.**
"""

# @title ⚠️ Optional install to save images: (Kaleido, Plotly & Chromium) Ignore for interactive view
INSTALL_PATCH = False  #@param {type:"boolean"}

if INSTALL_PATCH:
    import sys, os, subprocess
    import plotly.io as pio
    import shutil

    # Downgrade Kaleido to 0.2.1 to match Plotly 5.13.1
    subprocess.run([sys.executable, "-m", "pip", "install", "-q", "kaleido==0.2.1", "scikit-learn"], check=True)

    # Make sure Chromium & OS dependencies are installed
    subprocess.run(["apt-get", "-qq", "update"])
    subprocess.run([
        "apt-get", "-qq", "install", "-y", "chromium-browser",
        "libnss3", "libatk-bridge2.0-0", "libcups2", "libxcomposite1", "libxdamage1",
        "libxfixes3", "libxrandr2", "libgbm1", "libxkbcommon0", "libpango-1.0-0",
        "libcairo2", "libasound2"
    ])

    # Add Chromium to PATH for Kaleido
    os.environ["PATH"] += ":/usr/bin/chromium-browser"

    # Check Kaleido availability
    if pio.kaleido.scope is not None:
        print("✅ Shotgun patch applied: Plotly 5.13.1 + Kaleido 0.2.1. Restart runtime now.")
    else:
        print("⚠️ Patch applied, but Kaleido not detected. Restart runtime and try again.")
else:
    print(" ")  # Silent if skipped

#@title Cell 1 — Imports
import plotly.graph_objects as go
import plotly.express as px
import numpy as np
from sklearn.decomposition import PCA
from sklearn.preprocessing import StandardScaler
import pandas as pd
import warnings; warnings.filterwarnings('ignore')

# ── Camera presets ──────────────────────────────────────────────────────────
CAM_DEFAULT  = dict(eye=dict(x=1.5,  y=1.5,  z=1.0))
CAM_TOP      = dict(eye=dict(x=0,    y=0,    z=2.5))
CAM_FRONT    = dict(eye=dict(x=2.5,  y=0,    z=0))
CAM_SIDE     = dict(eye=dict(x=0,    y=2.5,  z=0))
CAM_PC1      = dict(eye=dict(x=2.5,  y=0.2,  z=0.2))
CAM_DIAGONAL = dict(eye=dict(x=1.5,  y=1.5,  z=0.2))

def save_views(fig, name, views):
    """Save static snapshots from multiple camera angles (requires kaleido)."""
    for label, camera in views.items():
        fig.update_layout(scene_camera=camera)
        path = f"{name}_{label}.png"
        try:
            fig.write_image(path, width=1200, height=800, scale=2)
            print(f"  Saved: {path}")
        except Exception as e:
            print(f"  Could not save {path}: {e}")

print("Imports OK.")

"""## Cell 2 — Run k-sweep simulation

Each `run_k()` call runs a fixed-k simulation (no phase switching).
Returns `(N_cycles, 3)` array of joint observer state `(x_a_meas, x_b_meas, corr_current)`. Burn-in of 200 cycles discarded.

**~1-2 minutes total for 11 k values.**
"""

#@title Cell 2 — k-sweep simulation
# Each call to run_k() produces a static fixed-k point cloud in (x_a_meas, x_b_meas, corr) space.
# No phase switching. One k value sustained for the full run.

import numpy as np

def run_k(k_val, N_cycles=2000, seed=42):
    """
    Run fixed-k simulation.
    Returns array shape (N_cycles, 3): (x_a_meas, x_b_meas, corr_current)
    """
    kBT=1.0; gamma=1.0; D_diff=kBT/gamma
    dt=0.01; tau_meas=10
    sigma_m=0.40
    field_volatility = np.sqrt(2*D_diff*tau_meas*dt)
    observer_offset  = 2.0
    W = 40

    rng_a = np.random.default_rng(seed)
    rng_b = np.random.default_rng(seed + 1000)

    xa = 0.0
    xb = observer_offset
    x0 = 0.0

    r_a_hist = []
    r_b_hist = []
    hull_pts  = []
    corr_current = 0.0

    for cycle in range(N_cycles):
        # Physics steps
        for step in range(tau_meas):
            noise_a = rng_a.standard_normal()
            noise_b = rng_b.standard_normal()
            drift_a = -k_val * (xa - x0) * dt / gamma
            drift_b = -k_val * (xb - x0) * dt / gamma
            diffusion = np.sqrt(2 * kBT * dt / gamma)
            xa += drift_a + diffusion * noise_a
            xb += drift_b + diffusion * noise_b

        # Measurement
        xa_meas = xa + sigma_m * rng_a.standard_normal()
        xb_meas = xb + sigma_m * rng_b.standard_normal()

        r_a = abs(xa_meas) / field_volatility
        r_b = abs(xb_meas) / field_volatility

        r_a_hist.append(r_a)
        r_b_hist.append(r_b)

        if len(r_a_hist) >= W:
            wa = np.array(r_a_hist[-W:])
            wb = np.array(r_b_hist[-W:])
            cc = np.corrcoef(wa, wb)[0, 1]
            corr_current = float(cc) if not np.isnan(cc) else 0.0

        hull_pts.append((float(xa_meas), float(xb_meas), float(corr_current)))

    return np.array(hull_pts)


# ── Run all k values ─────────────────────────────────────────────────────────
k_values = [0.0, 0.1, 0.2, 0.3, 0.5, 0.7, 1.0, 1.5, 2.0, 3.0, 5.0]

clouds = {}
for k in k_values:
    print(f"  Running k={k}...", end=' ', flush=True)
    clouds[k] = run_k(k, N_cycles=2000, seed=42)
    print(f"{len(clouds[k])} points")

# Discard burn-in transient
burn_in = 200
for k in k_values:
    clouds[k] = clouds[k][burn_in:]

print(f"\nAll k values complete. Points per cloud: {len(clouds[k_values[0]])}")

"""## Cell 3 — Normalize + PCA

Z-score normalization uses `k=0` background statistics.
PCA fit per k value. Background PCA basis stored for Viz 4.

Diagnostic table prints: eigenvalues, PC1 component weights, shape classification.
"""

#@title Cell 3 — Normalize + PCA per k value

from sklearn.preprocessing import StandardScaler
from sklearn.decomposition import PCA

# Normalize using k=0 statistics only (free-diffusion baseline)
scaler = StandardScaler()
scaler.fit(clouds[0.0])

clouds_norm = {}
for k in k_values:
    clouds_norm[k] = scaler.transform(clouds[k])

# PCA per k value
pca_results = {}
for k in k_values:
    pca = PCA(n_components=3)
    pca.fit(clouds_norm[k])
    pca_results[k] = {
        'eigenvalues': pca.explained_variance_ratio_,
        'components':  pca.components_,
        'transformed': pca.transform(clouds_norm[k]),
        'pca_obj':     pca
    }

# Background PCA basis (common projection for Viz 4)
pca_bg = PCA(n_components=3)
pca_bg.fit(clouds_norm[0.0])

# ── Diagnostics ──────────────────────────────────────────────────────────────
print("=" * 70)
print("SFE-06.4 — k-Sweep Manifold Summary")
print("=" * 70)
print(f"\n{'k':>6}  {'e1':>6}  {'e2':>6}  {'e3':>6}  "
      f"{'xa_w':>6}  {'xb_w':>6}  {'cc_w':>6}  shape")
print("-" * 70)

shapes = {}
for k in k_values:
    ev  = pca_results[k]['eigenvalues']
    c0  = pca_results[k]['components'][0]
    if   ev[0] < 0.50: shape = 'VOLUMETRIC'
    elif ev[0] < 0.70: shape = 'PLANAR'
    else:              shape = 'LINEAR'
    shapes[k] = shape
    print(f"{k:>6.1f}  {ev[0]:>6.3f}  {ev[1]:>6.3f}  {ev[2]:>6.3f}  "
          f"{c0[0]:>6.3f}  {c0[1]:>6.3f}  {c0[2]:>6.3f}  {shape}")

print("-" * 70)

print("\nTransition point (e1 first exceeds 0.65):")
for k in k_values:
    if pca_results[k]['eigenvalues'][0] > 0.65:
        print(f"  k = {k}")
        break
else:
    print("  Not reached in this sweep")

print("\nCorrelation dimension dominates (|cc_w| > 0.9) at:")
for k in k_values:
    c0 = pca_results[k]['components'][0]
    if abs(c0[2]) > 0.9:
        print(f"  k = {k}")
        break
else:
    print("  Not reached in this sweep")

print("=" * 70)

"""## Viz 1 — All clouds in raw joint space `(x_a, x_b, corr)`

**What to look for:**
- Blue `k=0` clouds spread wide — free diffusion in all directions
- Red `k=5` clouds compress toward origin — strong confinement
- **`CAM_TOP` view** (looking down correlation axis): spatial collapse of x_a, x_b
- **`CAM_DIAGONAL` view** (down x_a=x_b): symmetric confinement of both observers

Saved snapshots: `viz1_all_clouds_{overview,top_corr,front_xa,diagonal}.png`
"""

#@title Visualization 1 — All clouds in raw joint space (x_a, x_b, corr)

colors = px.colors.sample_colorscale(
    'Plasma', [i/(len(k_values)-1) for i in range(len(k_values))]
)

fig1 = go.Figure()

for i, k in enumerate(k_values):
    pts = clouds[k]
    idx = np.random.default_rng(0).choice(len(pts), min(200, len(pts)), replace=False)
    fig1.add_trace(go.Scatter3d(
        x=pts[idx, 0], y=pts[idx, 1], z=pts[idx, 2],
        mode='markers',
        marker=dict(size=2, color=colors[i], opacity=0.6),
        name=f'k={k}'
    ))

fig1.update_layout(
    title=dict(
        text='SFE-06.4 · Viz 1 — Joint Observer Manifold<br>'
             '<sup>blue=free diffusion (k=0) → red=confined (k=5)</sup>',
        font=dict(color='white')
    ),
    scene=dict(
        xaxis_title='x_a measurement',
        yaxis_title='x_b measurement',
        zaxis_title='correlation',
        bgcolor='black',
        xaxis=dict(backgroundcolor='#0a0a0a', gridcolor='#333', color='#aaa'),
        yaxis=dict(backgroundcolor='#0a0a0a', gridcolor='#333', color='#aaa'),
        zaxis=dict(backgroundcolor='#0a0a0a', gridcolor='#333', color='#aaa'),
    ),
    paper_bgcolor='#07080f',
    font=dict(color='white'),
    legend=dict(bgcolor='#0a0a0a', bordercolor='#333', font=dict(size=9)),
    width=950, height=750
)

fig1.show()

save_views(fig1, 'viz1_all_clouds', {
    'overview':  CAM_DEFAULT,
    'top_corr':  CAM_TOP,
    'front_xa':  CAM_FRONT,
    'diagonal':  CAM_DIAGONAL,
})

"""## Viz 2 — Centroid path through joint space

The white line connects the centroids of each k-value cloud.

**What to look for:**
- **Straight path** → linear transition from free to confined
- **Curved path** → intrinsic curvature of the manifold (non-trivial topology)
- **Inflection point** → identifies the critical k where geometry changes fastest

Centroid coordinates printed below the figure.
"""

#@title Visualization 2 — Centroid path through joint space

centroids = np.array([
    [k] + list(np.mean(clouds[k], axis=0))
    for k in k_values
])   # shape (11, 4): [k, x_a_mean, x_b_mean, corr_mean]

fig2 = go.Figure()

# Background ghost clouds (faint)
for i, k in enumerate(k_values):
    pts = clouds[k]
    idx = np.random.default_rng(1).choice(len(pts), min(80, len(pts)), replace=False)
    fig2.add_trace(go.Scatter3d(
        x=pts[idx, 0], y=pts[idx, 1], z=pts[idx, 2],
        mode='markers',
        marker=dict(size=1.5, color=colors[i], opacity=0.15),
        showlegend=False
    ))

# Centroid spine
fig2.add_trace(go.Scatter3d(
    x=centroids[:, 1], y=centroids[:, 2], z=centroids[:, 3],
    mode='lines+markers+text',
    line=dict(color='white', width=4),
    marker=dict(
        size=7,
        color=centroids[:, 0],
        colorscale='Plasma',
        showscale=True,
        colorbar=dict(title='k value', tickfont=dict(color='white'),
                      titlefont=dict(color='white'))
    ),
    text=[f'k={k}' for k in k_values],
    textposition='top center',
    textfont=dict(color='white', size=10),
    name='centroid path'
))

fig2.update_layout(
    title=dict(
        text='SFE-06.4 · Viz 2 — Manifold Spine<br>'
             '<sup>Straight = linear transition · Curved = intrinsic curvature</sup>',
        font=dict(color='white')
    ),
    scene=dict(
        xaxis_title='x_a mean',
        yaxis_title='x_b mean',
        zaxis_title='corr mean',
        bgcolor='black',
        xaxis=dict(backgroundcolor='#0a0a0a', gridcolor='#333', color='#aaa'),
        yaxis=dict(backgroundcolor='#0a0a0a', gridcolor='#333', color='#aaa'),
        zaxis=dict(backgroundcolor='#0a0a0a', gridcolor='#333', color='#aaa'),
    ),
    paper_bgcolor='#07080f',
    font=dict(color='white'),
    legend=dict(bgcolor='#0a0a0a'),
    width=950, height=750
)

fig2.show()

save_views(fig2, 'viz2_centroid_path', {
    'overview':  CAM_DEFAULT,
    'top_corr':  CAM_TOP,
    'diagonal':  CAM_DIAGONAL,
    'side_xb':   CAM_SIDE,
})

# Print centroid coordinates
print("\nCentroid path coordinates:")
print(f"{'k':>5}  {'xa_mean':>9}  {'xb_mean':>9}  {'corr_mean':>10}")
for row in centroids:
    print(f"{row[0]:>5.1f}  {row[1]:>9.4f}  {row[2]:>9.4f}  {row[3]:>10.4f}")

"""## Viz 3 — Transition curves (2D)

**Left panel:** e1 (dominant eigenvalue) and e2, e3 vs k.
Sharp inflection = phase transition. Smooth = continuous deformation.

**Right panel:** PC1 component weights vs k.
As k increases, the corr weight should approach 1.0 — confinement becomes a purely correlation event.

**This is the most diagnostic plot.** The shape of these curves determines the topology.
"""

#@title Visualization 3 — Transition curves (2D)

e1_vals  = [pca_results[k]['eigenvalues'][0] for k in k_values]
e2_vals  = [pca_results[k]['eigenvalues'][1] for k in k_values]
e3_vals  = [pca_results[k]['eigenvalues'][2] for k in k_values]
cw_vals  = [abs(pca_results[k]['components'][0][2]) for k in k_values]
xaw_vals = [abs(pca_results[k]['components'][0][0]) for k in k_values]
xbw_vals = [abs(pca_results[k]['components'][0][1]) for k in k_values]

from plotly.subplots import make_subplots

fig3 = make_subplots(
    rows=1, cols=2,
    subplot_titles=[
        'Eigenvalue Distribution vs k',
        'PC1 Component Weights vs k'
    ]
)

# Left: eigenvalues
for vals, name, col in [
    (e1_vals, 'e1 (dominant)', '#ff8c42'),
    (e2_vals, 'e2',            '#3dd6c8'),
    (e3_vals, 'e3',            '#b87aff'),
]:
    fig3.add_trace(go.Scatter(
        x=k_values, y=vals, mode='lines+markers',
        name=name, line=dict(color=col, width=2),
        marker=dict(size=7, color=col)
    ), row=1, col=1)

fig3.add_hline(y=0.65, row=1, col=1,
               line_dash='dot', line_color='#ff5f7e',
               annotation_text='LINEAR threshold',
               annotation_font=dict(color='#ff5f7e'))
fig3.add_hline(y=0.50, row=1, col=1,
               line_dash='dot', line_color='#f5c842',
               annotation_text='PLANAR threshold',
               annotation_font=dict(color='#f5c842'))

# Right: component weights
for vals, name, col in [
    (cw_vals,  '|corr weight|', '#f5c842'),
    (xaw_vals, '|xa weight|',   '#3dd6c8'),
    (xbw_vals, '|xb weight|',   '#60a5fa'),
]:
    fig3.add_trace(go.Scatter(
        x=k_values, y=vals, mode='lines+markers',
        name=name, line=dict(color=col, width=2),
        marker=dict(size=7, color=col)
    ), row=1, col=2)

fig3.add_hline(y=0.9, row=1, col=2,
               line_dash='dot', line_color='white',
               annotation_text='dominance 0.9',
               annotation_font=dict(color='white'))

fig3.update_layout(
    title=dict(
        text='SFE-06.4 · Viz 3 — Geometry Transition vs k<br>'
             '<sup>Sharp inflection = phase transition · Smooth = continuous deformation</sup>',
        font=dict(color='white')
    ),
    paper_bgcolor='#07080f',
    plot_bgcolor='#0a0a0a',
    font=dict(color='white'),
    legend=dict(bgcolor='#0a0a0a', bordercolor='#333'),
    width=1100, height=500
)
fig3.update_xaxes(title_text='k (confinement strength)', gridcolor='#333', color='#aaa')
fig3.update_yaxes(gridcolor='#333', color='#aaa', range=[0, 1.1])

fig3.show()

try:
    fig3.write_image('viz3_transition_curves.png', width=1400, height=600, scale=2)
    print("Saved: viz3_transition_curves.png")
except Exception as e:
    print(f"Could not save image: {e}")

"""## Viz 4 — All k values in background PCA basis

Projects every k-value cloud into the `k=0` PCA coordinate system.

**What to look for (orbit to `CAM_PC1` — looking straight down PC1):**
- `k=0` should look like a circle (sphere viewed along PC1)
- `k=5` should collapse to a point
- Intermediate k values trace the manifold surface between them

This is the topology: the connected surface visible across all k values.

Saved snapshots: `viz4_pca_space_{overview,along_PC1,top_PC3,side_PC2}.png`
"""

#@title Visualization 4 — All k values projected into background PCA basis
# This is the topology view: orbit along PC1 to see the manifold surface

fig4 = go.Figure()

for i, k in enumerate(k_values):
    projected = pca_bg.transform(clouds_norm[k])
    idx = np.random.default_rng(2).choice(
        len(projected), min(200, len(projected)), replace=False
    )
    fig4.add_trace(go.Scatter3d(
        x=projected[idx, 0],
        y=projected[idx, 1],
        z=projected[idx, 2],
        mode='markers',
        marker=dict(size=2, color=colors[i], opacity=0.5),
        name=f'k={k}'
    ))

fig4.update_layout(
    title=dict(
        text='SFE-06.4 · Viz 4 — All k values in Background PCA Basis<br>'
             '<sup>Look along PC1 (CAM_PC1 preset) to see sphere → point collapse</sup>',
        font=dict(color='white')
    ),
    scene=dict(
        xaxis_title='PC1',
        yaxis_title='PC2',
        zaxis_title='PC3',
        bgcolor='black',
        xaxis=dict(backgroundcolor='#0a0a0a', gridcolor='#333', color='#aaa'),
        yaxis=dict(backgroundcolor='#0a0a0a', gridcolor='#333', color='#aaa'),
        zaxis=dict(backgroundcolor='#0a0a0a', gridcolor='#333', color='#aaa'),
    ),
    paper_bgcolor='#07080f',
    font=dict(color='white'),
    legend=dict(bgcolor='#0a0a0a', bordercolor='#333', font=dict(size=9)),
    width=950, height=750
)

fig4.show()

save_views(fig4, 'viz4_pca_space', {
    'overview':  CAM_DEFAULT,
    'along_PC1': CAM_PC1,
    'top_PC3':   CAM_TOP,
    'side_PC2':  CAM_SIDE,
})

"""## Viz 5 — Animated k-sweep *(optional, slower)*

Each animation frame is one k value.
Color encodes shape: **teal = VOLUMETRIC · yellow = PLANAR · red = LINEAR**

Use the play button. Orbit between frames to see geometry from different angles.
"""

#@title Visualization 5 — Animated k-sweep (optional, slower to render)
# Each frame is one k value. Watch the geometry transform continuously.

import pandas as pd

records = []
for k in k_values:
    pts = clouds[k]
    # Subsample each cloud for animation performance
    idx = np.random.default_rng(3).choice(len(pts), min(150, len(pts)), replace=False)
    for j in idx:
        records.append({
            'xa':   pts[j, 0],
            'xb':   pts[j, 1],
            'corr': pts[j, 2],
            'k':    str(k),
            'shape': shapes[k]
        })

df_anim = pd.DataFrame(records)

shape_colors = {'VOLUMETRIC': '#3dd6c8', 'PLANAR': '#f5c842', 'LINEAR': '#ff5f7e'}

fig5 = px.scatter_3d(
    df_anim, x='xa', y='xb', z='corr',
    color='shape',
    animation_frame='k',
    color_discrete_map=shape_colors,
    title='SFE-06.4 · Viz 5 — k-Sweep Animation (teal=volumetric, yellow=planar, red=linear)',
    labels={'xa': 'x_a', 'xb': 'x_b', 'corr': 'correlation'},
    opacity=0.7,
)
fig5.update_traces(marker=dict(size=3))
fig5.update_layout(
    width=950, height=750,
    paper_bgcolor='#07080f',
    font=dict(color='white'),
    scene=dict(
        bgcolor='black',
        xaxis=dict(backgroundcolor='#0a0a0a', gridcolor='#333', color='#aaa'),
        yaxis=dict(backgroundcolor='#0a0a0a', gridcolor='#333', color='#aaa'),
        zaxis=dict(backgroundcolor='#0a0a0a', gridcolor='#333', color='#aaa'),
    )
)
fig5.show()
print("\nViz 5: Press play to animate k from 0→5.")
print("Watch geometry transform: volumetric cloud → planar pancake → linear spike.")

"""## Summary

Prints transition points, monotonicity check, and lineage.
"""

#@title Final summary

print("=" * 70)
print("SFE-06.4 — k-Sweep Results")
print("=" * 70)
print(f"\n{'k':>6}  {'e1':>6}  {'shape'}")
print("-" * 30)
for k in k_values:
    ev = pca_results[k]['eigenvalues']
    print(f"{k:>6.1f}  {ev[0]:>6.3f}  {shapes[k]}")
print("-" * 30)

# Find transition points
e1_vals = [pca_results[k]['eigenvalues'][0] for k in k_values]
cw_vals = [abs(pca_results[k]['components'][0][2]) for k in k_values]

planar_k  = next((k for k in k_values if pca_results[k]['eigenvalues'][0] > 0.5),  None)
linear_k  = next((k for k in k_values if pca_results[k]['eigenvalues'][0] > 0.65), None)
corrdom_k = next((k for k in k_values if abs(pca_results[k]['components'][0][2]) > 0.9), None)

print(f"\nVOLUMETRIC → PLANAR transition:  k = {planar_k}")
print(f"PLANAR     → LINEAR  transition:  k = {linear_k}")
print(f"Correlation axis dominates (>0.9): k = {corrdom_k}")

# Check monotonicity
e1_monotone = all(e1_vals[i] <= e1_vals[i+1] for i in range(len(e1_vals)-1))
cw_monotone = all(cw_vals[i] <= cw_vals[i+1] for i in range(len(cw_vals)-1))
print(f"\ne1 monotonically increases with k: {'YES' if e1_monotone else 'NO  (check sweep)'}")
print(f"corr_weight monotonically increases: {'YES' if cw_monotone else 'NO  (check sweep)'}")

print(f"\n{'SUCCESS' if e1_monotone else 'CHECK'}: All {len(k_values)} k values produced distinct clouds")

print("\n" + "=" * 70)
print("LINEAGE")
print("  05.12b  Showed what a matched filter cannot see")
print("  05.13b  Showed what a single decoupled observer can see")
print("  SFE-06  Showed what the relationship between observers can see")
print("  SFE-06.2 Showed the shape of that relationship")
print("  SFE-06.3 Navigated inside the shape")
print("  SFE-06.4 Maps the full manifold across all field conditions")
print("=" * 70)

"""## Lineage

| Version | Result |
|---------|--------|
| 05.12b  | Showed what a matched filter cannot see |
| 05.13b  | Showed what a single decoupled observer can see |
| SFE-06  | Showed what the relationship between observers can see |
| SFE-06.2 | Showed the shape of that relationship |
| SFE-06.3 | Navigated inside the shape |
| SFE-06.4 | Maps the full manifold across all field conditions |

---

#
"""
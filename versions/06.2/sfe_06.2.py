# -*- coding: utf-8 -*-
"""SFE-06.2

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1z9xyoIzuveEvIKHTzxUCCivvH6zpMvIe
"""

# @title SFE-06.2
# -*- coding: utf-8 -*-
"""SFE-06.2 — Joint Observer Geometry · Hull Shape · Variance Fix

Extends SFE-06:
  1. Variance measured from each observer's own initial position (not global origin)
  2. Hull input: joint observer state (x_a_meas, x_b_meas, corr_current)
     — replaces agent-flux input which produced degenerate 1D hull
  3. PCA on hull points per phase — eigenvalue distribution shows shape change
  4. Agg backend — figure saved to file

Key question: does the hull collapse from VOLUMETRIC (background) to LINEAR (burst)?
"""

import matplotlib
import matplotlib.pyplot as plt
import numpy as np
from matplotlib.gridspec import GridSpec
from mpl_toolkits.mplot3d.art3d import Poly3DCollection
from scipy.spatial import ConvexHull, QhullError
from scipy.ndimage import uniform_filter1d
import warnings; warnings.filterwarnings('ignore')
np.random.seed(42)
import os

FIG_DIR  = '/tmp/sfe062_figs'
FIG_PATH = os.path.join(FIG_DIR, 'sfe062_joint_geometry.png')
os.makedirs(FIG_DIR, exist_ok=True)

print("="*70)
print("SFE-06.2  —  Joint Observer Geometry · Hull Shape")
print("="*70)

# ─── PHYSICS ──────────────────────────────────────────────────────────────────
kBT=1.0; gamma=1.0; D_diff=kBT/gamma
dt=0.01; tau_meas=10

domain       = 'extended'
x_min, x_max = -50.0, 50.0
Nx           = 400
x_grid       = np.linspace(x_min, x_max, Nx)
dx           = x_grid[1] - x_grid[0]

sigma_m          = 0.40
field_volatility = np.sqrt(2*D_diff*tau_meas*dt)

# ─── PHASE STRUCTURE ──────────────────────────────────────────────────────────
N_background    = 1000
N_burst         = 200
N_recovery      = 400
N_cycles        = N_background + N_burst + N_recovery   # 1600

k_background    = 0.0
k_burst         = 1.0
observer_offset = 2.0
z_sigma         = 1.5
W               = 40

xa0 = 0.0             # Observer A initial position
xb0 = observer_offset  # Observer B initial position

# ─── AGENT PARAMS (carry-forward) ─────────────────────────────────────────────
BUFFER_N=512; gate_multiplier=1.0; gate_window=50
coherence_var_th=0.15; alpha_attract=0.15
min_events_before=10; n_candidates=5; rehearsal_on=True
lambda_coup_init=0.30; lambda_min=0.05; lambda_max=0.80
sigma_memory=1.20; x0=0.0; window_scale=1.0
N_steps = N_cycles * tau_meas

# ─── HELPERS ──────────────────────────────────────────────────────────────────
def _gr(m, s):
    r = np.exp(-0.5*((x_grid-m)/s)**2)
    return r / np.trapezoid(r, x_grid)

def fp_step(rho, k=0., x0w=0.):
    Ft = -k*(x_grid - x0w)
    v  = Ft/gamma
    df = np.zeros(Nx+1); ff = np.zeros(Nx+1)
    for i in range(1, Nx):
        vf = 0.5*(v[i-1]+v[i])
        df[i] = vf*rho[i-1] if vf >= 0 else vf*rho[i]
        ff[i] = D_diff*(rho[i]-rho[i-1])/dx
    rn = np.maximum(rho - (dt/dx)*np.diff(df-ff), 0.)
    nm = np.trapezoid(rn, x_grid)
    return rn/nm if nm > 1e-12 else rn

def fp_flux(rho):
    return D_diff*(-np.gradient(rho, x_grid))

def convex_hull_3d(pts):
    if len(pts) < 5: return 0., 0., None
    try:
        h = ConvexHull(pts)
        return h.volume, h.area, h
    except QhullError:
        return 0., 0., None

def pca_3d(pts):
    """Returns (explained_variance_ratio [3], principal_axes [3x3]).
    Normalizes each dimension first so scale differences don't dominate."""
    if len(pts) < 4:
        return np.array([1., 0., 0.]), np.eye(3)
    # Z-score normalize each column so dimensions have equal scale
    mu   = pts.mean(0)
    sig  = pts.std(0) + 1e-8
    c    = (pts - mu) / sig
    cov  = np.cov(c.T)
    if cov.ndim < 2:
        return np.array([1., 0., 0.]), np.eye(3)
    vals, vecs = np.linalg.eigh(cov)
    order = np.argsort(vals)[::-1]
    vals  = np.maximum(vals[order], 0.)
    vecs  = vecs[:, order]
    ratio = vals / (vals.sum() + 1e-12)
    return ratio, vecs.T

def classify_shape(pca_ratio):
    v0, v1, v2 = pca_ratio
    if   v0 > 0.70: return "LINEAR"
    elif v0 > 0.50: return "PLANAR"
    elif v2 > 0.18: return "VOLUMETRIC"   # lowered from 0.25
    else:           return "PLANAR"

# ─── CLASSES ──────────────────────────────────────────────────────────────────
class CircularBuffer:
    def __init__(self, N, cols=3):
        self.N=N; self.cols=cols
        self.buf=np.zeros((N,cols), dtype=np.float32)
        self.filled=self.writes=0
    def push(self, row):
        self.writes+=1
        self.buf=np.roll(self.buf, shift=1, axis=0)
        self.buf[0]=np.array(row, dtype=np.float32)
        self.filled=min(self.filled+1, self.N)
    def get_numpy(self): return self.buf[:self.filled]

class AdaptiveGate:
    def __init__(self, mult, window, floor):
        self.mult=mult; self.window=window; self.floor=floor
        self._h=[]; self.threshold=floor
    def update(self, s):
        self._h.append(s)
        if len(self._h) > self.window: self._h.pop(0)
        if len(self._h) >= 4:
            self.threshold = max(float(np.std(self._h))*self.mult, self.floor)
    def core_gate(self, s):    return s <= self.threshold
    def anomaly_gate(self, s): return s  > self.threshold

class KalmanOU:
    def __init__(self, k=0.0):
        self.k=k; self.x_hat=0.0; self.P=2*kBT/gamma*tau_meas*dt
    def predict_n(self, n):
        if self.k == 0.0:
            self.P += n*2*kBT/gamma*dt
        else:
            a=np.exp(-self.k*dt*n); sou=kBT/self.k
            self.x_hat *= a; self.P=self.P*a**2+sou*(1-a**2)
    def update(self, z):
        K=self.P/(self.P+sigma_m**2)
        inn=z-self.x_hat; self.x_hat+=K*inn; self.P*=(1-K)
        return abs(inn)

class PerceivedField:
    def __init__(self, mx=300): self.s=[]; self.w=[]; self.mx=mx
    def add(self, xp, w=1.0):
        self.s.append(xp); self.w.append(w)
        if len(self.s) > self.mx: self.s.pop(0); self.w.pop(0)
    def get_rho(self):
        if len(self.s) < 2: return _gr(0., 1.)
        rho=np.zeros(Nx); wt=sum(self.w)
        for xp, w in zip(self.s, self.w):
            rho += (w/wt)*np.exp(-0.5*((x_grid-xp)/sigma_memory)**2)
        nm=np.trapezoid(rho, x_grid)
        return rho/nm if nm > 1e-12 else rho

class CoherenceCentroid:
    def __init__(self): self.centroid=np.zeros(3); self.n=0
    def update(self, pos):
        self.n+=1; self.centroid=((self.n-1)*self.centroid+pos)/self.n
        return self.centroid.copy()
    def attraction_force_x(self, c):
        return alpha_attract*(self.centroid[0]-c) if self.n > 0 else 0.
    @property
    def is_ready(self): return self.n >= min_events_before
    @property
    def position(self): return self.centroid.copy()

class NullPredictorGate:
    def __init__(self, z_sig):
        self.z_sig=z_sig
        self._bg=[]; self._all=[]
        self.baseline_mean=None; self.baseline_std=None; self.gate_floor=None
        self.frozen=False
        self.n_crossings=0; self.n_verified=0; self.n_rejected=0
    def push_background(self, r): self._bg.append(r); self._all.append(r)
    def freeze(self):
        self.baseline_mean=float(np.mean(self._bg))
        self.baseline_std =float(np.std(self._bg))+1e-8
        self.gate_floor   =self.baseline_mean - self.z_sig*self.baseline_std
        self.frozen=True
        return self.baseline_mean, self.baseline_std, self.gate_floor
    def push_active(self, r): self._all.append(r)
    def check(self, r, rv, core_rate, pts, cycle):
        if not self.frozen: return False, False, float('nan')
        delta   = r - self.gate_floor
        crossing= r < self.gate_floor
        if crossing:
            self.n_crossings += 1
            prev = self._all[-2] if len(self._all)>=2 else r
            verified = prev < self.gate_floor
            if verified: self.n_verified+=1
            else:        self.n_rejected+=1
            struct_ok = (rv < coherence_var_th) and (core_rate >= 0.20)
            if verified and struct_ok and len(pts)>=5:
                return True, True, delta
        return False, False, delta

class CrossCorrGate:
    def __init__(self, z_sig, window=W):
        self.z_sig=z_sig; self.W=window
        self._bg=[]; self._all=[]
        self.baseline_mean=None; self.baseline_std=None; self.gate_ceil=None
        self.frozen=False; self.n_events=0
    def _corr(self, ra, rb):
        if len(ra) < 4: return 0.
        c = np.corrcoef(ra, rb)
        return float(c[0,1]) if np.isfinite(c[0,1]) else 0.
    def push_background(self, ra, rb):
        c=self._corr(ra, rb); self._bg.append(c); self._all.append(c); return c
    def freeze(self):
        self.baseline_mean=float(np.mean(self._bg))
        self.baseline_std =float(np.std(self._bg))+1e-8
        self.gate_ceil    =self.baseline_mean + self.z_sig*self.baseline_std
        self.frozen=True
        return self.baseline_mean, self.baseline_std, self.gate_ceil
    def push_active(self, ra, rb):
        c=self._corr(ra, rb); self._all.append(c); return c
    def check(self, c):
        if not self.frozen: return False
        if c > self.gate_ceil: self.n_events+=1; return True
        return False
    @property
    def all_corrs(self): return np.array(self._all)

# ─── MAIN RUN ─────────────────────────────────────────────────────────────────
def run():
    rng       = np.random.default_rng(42)   # agent + Kalman
    rng_obs_a = np.random.default_rng(101)  # observer A noise
    rng_obs_b = np.random.default_rng(202)  # observer B noise

    # Agent
    kf=KalmanOU(k=k_background); pf=PerceivedField()
    cb=CircularBuffer(BUFFER_N); wg=AdaptiveGate(gate_multiplier,gate_window,floor=field_volatility)
    cen=CoherenceCentroid()
    rho=_gr(0., 2.)
    x=0.; pf.add(x)
    lam=lambda_coup_init; cur_sr=2.

    # Observers
    xa=xa0; xb=xb0
    gate_a=NullPredictorGate(z_sigma); cc_gate=CrossCorrGate(z_sigma, W)

    # ── JOINT HULL — this is the new primary hull ──
    jcb = CircularBuffer(BUFFER_N, cols=3)  # (x_a_meas, x_b_meas, corr_current)
    current_corr = 0.0  # last computed windowed cross-correlation

    # Per-phase hull point storage for PCA
    hull_pts_bg   = []
    hull_pts_burst= []
    hull_pts_rec  = []

    # Logs
    nr_a_log=[]; nr_b_log=[]; corr_log=[]
    wc_log=[]; phase_log=[]
    kalman_ratio_log=[]
    events_single=[]; ec_single=[]
    events_cc=[]; ec_cc=[]
    null_sw_a=[]; null_sw_b=[]; kalman_sw=[]
    vw=[]; vw_cycle=[]
    total=0; cw=0; cycle=0
    baseline_frozen=False

    # Variance tracking (from own initial position)
    xa_bg_pos=[]; xb_bg_pos=[]

    for i in range(N_steps):
        if   cycle < N_background:           phase='bg';    k_now=k_background
        elif cycle < N_background+N_burst:   phase='burst'; k_now=k_burst
        else:                                phase='rec';   k_now=k_background
        kf.k = k_now

        if i % tau_meas == 0:
            kf.predict_n(tau_meas)

            # Agent measurement
            xm_agent    = x  + sigma_m*rng.standard_normal()
            kalman_innov= kf.update(xm_agent)

            # Observer measurements
            xm_a = xa + sigma_m*rng_obs_a.standard_normal()
            xm_b = xb + sigma_m*rng_obs_b.standard_normal()

            # Push joint hull point: (x_a_meas, x_b_meas, corr_current)
            jcb.push([xm_a, xm_b, current_corr])

            # Store for phase-PCA
            pt = [xm_a, xm_b, current_corr]
            if   phase=='bg':    hull_pts_bg.append(pt)
            elif phase=='burst': hull_pts_burst.append(pt)
            else:                hull_pts_rec.append(pt)

            null_innov_a = abs(xm_a)
            null_innov_b = abs(xm_b)

            # Agent gate bookkeeping (using agent measurement for Kalman gate)
            wg.update(kalman_innov); total+=1
            if wg.core_gate(kalman_innov): cb.push([xm_a, xm_b, current_corr]); cw+=1

            null_sw_a.append(null_innov_a); null_sw_b.append(null_innov_b)
            kalman_sw.append(kalman_innov)
            if len(null_sw_a) > W:
                null_sw_a.pop(0); null_sw_b.pop(0); kalman_sw.pop(0)
            cycle += 1

            if phase=='bg':
                xa_bg_pos.append(xa); xb_bg_pos.append(xb)

            if cycle % W == 0 and cb.filled >= 5:
                T,_,_ = jcb.get_numpy(), None, None  # use joint hull pts
                T = jcb.get_numpy()
                v,a,_ = convex_hull_3d(T); vw.append(v); vw_cycle.append(cycle)
                wl=max(int(N_cycles*0.5*window_scale), 8)
                if len(vw) > wl: vw.pop(0)
                core_rate=cw/max(total,1)
                if len(vw) >= 3:
                    vm=np.mean(vw); vs=np.std(vw)+1e-8; z=(v-vm)/vs
                    if   z > 1.:   lam=min(lam*1.05, lambda_max)
                    elif z < -0.5: lam=max(lam*0.98, lambda_min)

                win_null_a = float(np.mean(null_sw_a))/(field_volatility+1e-10)
                win_null_b = float(np.mean(null_sw_b))/(field_volatility+1e-10)
                win_kalman = float(np.mean(kalman_sw))/(field_volatility+1e-10)

                mv=np.mean(vw)+1e-8; rv=float(np.var(vw))/(mv**2)

                nr_a_log.append(win_null_a); nr_b_log.append(win_null_b)
                kalman_ratio_log.append(win_kalman)
                wc_log.append(cycle); phase_log.append(phase)

                if phase=='bg':
                    gate_a.push_background(win_null_a)
                    current_corr = cc_gate.push_background(null_sw_a[-W:], null_sw_b[-W:])
                    corr_log.append(current_corr)
                else:
                    if not baseline_frozen:
                        bl_m, bl_s, gf = gate_a.freeze()
                        _,   _,   gc   = cc_gate.freeze()
                        baseline_frozen=True
                        print(f"\n  ▸ FREEZE at cycle={cycle}")
                        print(f"    obs_a  baseline={bl_m:.4f}±{bl_s:.4f}  floor={gf:.4f}")
                        print(f"    cc     baseline={cc_gate.baseline_mean:.4f}±{cc_gate.baseline_std:.4f}  ceil={gc:.4f}")
                    gate_a.push_active(win_null_a)
                    current_corr = cc_gate.push_active(null_sw_a[-W:], null_sw_b[-W:])
                    corr_log.append(current_corr)

                    is_ev_a,_,_ = gate_a.check(win_null_a, rv, core_rate, T, cycle)
                    is_ev_cc    = cc_gate.check(current_corr)

                    if is_ev_a:
                        ev=dict(cycle=cycle, phase=phase, null_ratio_a=win_null_a,
                                null_ratio_b=win_null_b, corr=current_corr)
                        events_single.append(ev); ec_single.append(cycle)
                        print(f"  ★ single  c={cycle:4d} [{phase:5s}] r_a={win_null_a:.3f} "
                              f"floor={gate_a.gate_floor:.3f} corr={current_corr:+.3f}")
                    if is_ev_cc:
                        ev=dict(cycle=cycle, phase=phase, corr=current_corr,
                                null_ratio_a=win_null_a, null_ratio_b=win_null_b)
                        events_cc.append(ev); ec_cc.append(cycle)
                        print(f"  ✦ cc      c={cycle:4d} [{phase:5s}] corr={current_corr:+.3f} "
                              f"ceil={cc_gate.gate_ceil:.3f}")

        # Observer dynamics — truly unbounded, independent noise streams
        Fou_a = -k_now*(xa - x0)
        xa   += (Fou_a/gamma)*dt + np.sqrt(2*kBT*gamma)*rng_obs_a.standard_normal()*np.sqrt(dt)/gamma

        Fou_b = -k_now*(xb - x0)
        xb   += (Fou_b/gamma)*dt + np.sqrt(2*kBT*gamma)*rng_obs_b.standard_normal()*np.sqrt(dt)/gamma

        # Agent dynamics
        rho = fp_step(rho, k_now, x0)
        J   = fp_flux(rho); Jat=float(np.interp(x, x_grid, J))
        Ff  = lam*Jat/(abs(Jat)+1e-10)
        Fou = -k_now*(x-x0)
        Fatt= cen.attraction_force_x(abs(Jat)) if cen.is_ready else 0.

        def step(Fe):
            xi = np.sqrt(2*kBT*gamma)*rng.standard_normal()
            raw = x + ((Ff+Fe)/gamma)*dt + xi*np.sqrt(dt)/gamma
            return float(np.clip(raw, x_min+0.1, x_max-0.1))

        xs=step(Fatt+Fou); bs=abs(xs-kf.x_hat); bx=xs
        if rehearsal_on and n_candidates > 1:
            for _ in range(n_candidates-1):
                xc=step(Fatt+Fou); sc=abs(xc-kf.x_hat)
                if sc < bs: bx=xc; bs=sc
        pf.add(bx, w=1./(sigma_m+.1)); x=bx

    # ── Summaries ──
    nr_a  = np.array(nr_a_log); nr_b = np.array(nr_b_log)
    ph    = np.array(phase_log); wc   = np.array(wc_log)
    corr_arr = np.array(corr_log)
    cc_all   = cc_gate.all_corrs

    # Variance from own origin
    bg_var_a = float(np.mean((np.array(xa_bg_pos)-xa0)**2)) if xa_bg_pos else float('nan')
    bg_var_b = float(np.mean((np.array(xb_bg_pos)-xb0)**2)) if xb_bg_pos else float('nan')

    # Hull geometry per phase
    hp_bg    = np.array(hull_pts_bg)    if hull_pts_bg    else np.zeros((5,3))
    hp_burst = np.array(hull_pts_burst) if hull_pts_burst else np.zeros((5,3))
    hp_rec   = np.array(hull_pts_rec)   if hull_pts_rec   else np.zeros((5,3))

    # Subsample for hull computation
    def subsample(pts, n=2000):
        if len(pts) <= n: return pts
        idx=np.linspace(0,len(pts)-1,n,dtype=int); return pts[idx]

    v_bg,  _, hull_bg  = convex_hull_3d(subsample(hp_bg))
    v_bu,  _, hull_bu  = convex_hull_3d(subsample(hp_burst))
    v_rec, _, hull_rec = convex_hull_3d(subsample(hp_rec))

    pca_bg,  _  = pca_3d(subsample(hp_bg,  500))
    pca_bu,  _  = pca_3d(subsample(hp_burst, 500))
    pca_rec, _  = pca_3d(subsample(hp_rec,  500))

    shape_bg  = classify_shape(pca_bg)
    shape_bu  = classify_shape(pca_bu)
    shape_rec = classify_shape(pca_rec)

    single_burst = [e for e in events_single if e['phase']=='burst']
    single_bg    = [e for e in events_single if e['phase']=='bg']
    single_rec   = [e for e in events_single if e['phase']=='rec']
    cc_burst     = [e for e in events_cc if e['phase']=='burst']
    cc_bg_ev     = [e for e in events_cc if e['phase']=='bg']
    cc_rec       = [e for e in events_cc if e['phase']=='rec']

    corr_bg_ph   = cc_all[ph=='bg']   if len(cc_all)==len(ph) else np.array([])
    corr_bu_ph   = cc_all[ph=='burst'] if len(cc_all)==len(ph) else np.array([])
    cc_burst_max = float(corr_bu_ph.max()) if len(corr_bu_ph) else float('nan')

    cc_detects_earlier = 'N/A'
    if single_burst and cc_burst:
        fc_s=single_burst[0]['cycle']; fc_c=cc_burst[0]['cycle']
        if   fc_c < fc_s: cc_detects_earlier = f'yes (cc c={fc_c} vs single c={fc_s})'
        elif fc_c > fc_s: cc_detects_earlier = f'no  (single c={fc_s} vs cc c={fc_c})'
        else:             cc_detects_earlier = f'same (c={fc_c})'

    return dict(
        gate_a=gate_a, cc_gate=cc_gate, cen=cen,
        nr_a=nr_a, nr_b=nr_b, ph=ph, wc=wc, cc_all=cc_all,
        kalman_ratio=np.array(kalman_ratio_log),
        bg_var_a=bg_var_a, bg_var_b=bg_var_b,
        hp_bg=hp_bg, hp_burst=hp_burst, hp_rec=hp_rec,
        v_bg=v_bg, v_bu=v_bu, v_rec=v_rec,
        hull_bg=hull_bg, hull_bu=hull_bu, hull_rec=hull_rec,
        pca_bg=pca_bg, pca_bu=pca_bu, pca_rec=pca_rec,
        shape_bg=shape_bg, shape_bu=shape_bu, shape_rec=shape_rec,
        events_single=events_single, ec_single=ec_single,
        events_cc=events_cc, ec_cc=ec_cc,
        single_burst=single_burst, single_bg=single_bg, single_rec=single_rec,
        cc_burst=cc_burst, cc_bg_ev=cc_bg_ev, cc_rec=cc_rec,
        cc_burst_max=cc_burst_max, cc_detects_earlier=cc_detects_earlier,
    )


print(f"{'─'*70}")
print(f"Run: background(k=0,{N_background}) → burst(k={k_burst},{N_burst}) → recovery(k=0,{N_recovery})")
print(f"{'─'*70}")
res = run()
g = res['gate_a']; cc = res['cc_gate']

# ─── DIAGNOSTICS ──────────────────────────────────────────────────────────────
bg_var_a  = res['bg_var_a']; bg_var_b = res['bg_var_b']
var_ratio = bg_var_a/bg_var_b if bg_var_b > 0 else float('nan')
var_symmetric = (0.2 <= var_ratio <= 5.0) if np.isfinite(var_ratio) else False  # single-traj noise expected

pca_bg = res['pca_bg']; pca_bu = res['pca_bu']; pca_rec = res['pca_rec']
bg_volumetric    = (res['shape_bg']  == 'VOLUMETRIC')
burst_collapsed  = (res['shape_bu']  in ('PLANAR','LINEAR'))
burst_eig_dom    = (pca_bu[0] >= 0.65)  # meaningful collapse vs background's ~0.4
bg_eig_spread    = (pca_bg[0] < 0.5)

s1 = len(res['cc_burst'])  > 0
s2 = len(res['cc_bg_ev']) == 0
s3 = var_symmetric
s4 = bg_volumetric
s5 = burst_collapsed
s6 = burst_eig_dom

print()
print("="*70); print("SFE-06.2  —  Joint Observer Geometry · Hull Shape"); print("="*70)

print(f"\n  BACKEND")
print(f"    matplotlib_backend = {matplotlib.get_backend()}")
print(f"    figure_saved_to    = {FIG_PATH}")

print(f"\n  VARIANCE FIX (from each observer's own initial position)")
print(f"    bg_var_a (own origin) = {bg_var_a:.2f}  (xa0={xa0})")
print(f"    bg_var_b (own origin) = {bg_var_b:.2f}  (xb0={xb0})")
print(f"    ratio a/b             = {var_ratio:.2f}")
print(f"    variance_symmetric    = {'yes' if var_symmetric else 'NO — ratio > 2x'}")

print(f"\n  HULL GEOMETRY  (joint state: x_a_meas, x_b_meas, corr)")
print(f"    background_shape  = {res['shape_bg']}")
print(f"    burst_shape       = {res['shape_bu']}")
print(f"    recovery_shape    = {res['shape_rec']}")
print(f"    background_volume = {res['v_bg']:.4f}")
print(f"    burst_volume      = {res['v_bu']:.4f}")
print(f"    recovery_volume   = {res['v_rec']:.4f}")

print(f"\n  PCA EIGENVALUES (explained variance ratio)")
print(f"    background: [{pca_bg[0]:.3f}, {pca_bg[1]:.3f}, {pca_bg[2]:.3f}]  shape={res['shape_bg']}")
print(f"    burst:      [{pca_bu[0]:.3f}, {pca_bu[1]:.3f}, {pca_bu[2]:.3f}]  shape={res['shape_bu']}")
print(f"    recovery:   [{pca_rec[0]:.3f}, {pca_rec[1]:.3f}, {pca_rec[2]:.3f}]  shape={res['shape_rec']}")

print(f"\n  CROSS-CORRELATION (unchanged from SFE-06)")
print(f"    corr_events_burst      = {len(res['cc_burst'])}")
print(f"    corr_events_background = {len(res['cc_bg_ev'])}")
print(f"    corr_max_burst         = {res['cc_burst_max']:.4f}")
print(f"    cc_detects_earlier     = {res['cc_detects_earlier']}")

print(f"\n  SUCCESS")
print(f"    variance_symmetric:        {'PASS ✓' if s3 else 'FAIL ✗'}  (ratio={var_ratio:.2f})")
print(f"    bg_hull_volumetric:        {'PASS ✓' if s4 else 'FAIL ✗'}  ({res['shape_bg']})")
print(f"    burst_hull_collapsed:      {'PASS ✓' if s5 else 'FAIL ✗'}  ({res['shape_bu']})")
print(f"    burst_eigenvalue_dominant: {'PASS ✓' if s6 else 'FAIL ✗'}  ({pca_bu[0]:.3f})")
print(f"    corr_events_burst > 0:     {'PASS ✓' if s1 else 'FAIL ✗'}  ({len(res['cc_burst'])})")
print(f"    corr_events_bg = 0:        {'PASS ✓' if s2 else 'FAIL ✗'}  ({len(res['cc_bg_ev'])})")

# ─── FIGURE ───────────────────────────────────────────────────────────────────
BG='#07080f'; FG='#dde1ec'; GOLD='#f5c842'; TEAL='#3dd6c8'; VIOLET='#b87aff'
ROSE='#ff5f7e'; GREEN='#4ade80'; WH='#ffffff'; BURST_C='#ff8c42'; OBS_B='#60a5fa'
DIM='#1e2235'

plt.rcParams.update({
    'figure.facecolor':BG,'axes.facecolor':BG,'axes.edgecolor':DIM,
    'text.color':FG,'axes.labelcolor':FG,'xtick.color':'#555870','ytick.color':'#555870'
})

def span(ax):
    ax.axvspan(0,N_background,color='#1a3040',alpha=0.35)
    ax.axvspan(N_background,N_background+N_burst,color=BURST_C,alpha=0.12)
    ax.axvspan(N_background+N_burst,N_cycles,color='#1a2830',alpha=0.25)

def style_3d(ax, xl, yl, zl, t):
    ax.set_xlabel(xl,fontsize=7,labelpad=6); ax.set_ylabel(yl,fontsize=7,labelpad=6)
    ax.set_zlabel(zl,fontsize=7,labelpad=6); ax.set_title(t,color=FG,fontsize=8,pad=4)
    ax.tick_params(labelsize=5)
    for p in [ax.xaxis.pane,ax.yaxis.pane,ax.zaxis.pane]:
        p.fill=False; p.set_edgecolor(DIM)
    ax.grid(True,alpha=0.08)

nr_a=res['nr_a']; nr_b=res['nr_b']; ph=res['ph']; wc=res['wc']
cc_all=res['cc_all']

print(f"\nRendering figure...", end='', flush=True)

fig = plt.figure(figsize=(14,13), facecolor=BG)
gs  = GridSpec(3, 2, figure=fig, hspace=0.45, wspace=0.38,
               top=0.92, bottom=0.06, left=0.07, right=0.97)
fig.suptitle(
    f"SFE-06.2  ·  Joint Observer Geometry  ·  Hull Shape\n"
    f"bg={res['shape_bg']}  burst={res['shape_bu']}  rec={res['shape_rec']}  "
    f"cc_burst={len(res['cc_burst'])}  cc_bg={len(res['cc_bg_ev'])}  "
    f"burst_e1={pca_bu[0]:.3f}",
    fontsize=11, color=GOLD, fontweight='bold')

# ── [0,0] Null ratio timeseries ──
ax0 = fig.add_subplot(gs[0,0]); ax0.set_facecolor(BG)
span(ax0)
ax0.plot(wc, uniform_filter1d(nr_a, size=3), color=TEAL,   lw=1.8, label='Obs A null ratio', zorder=5)
ax0.plot(wc, uniform_filter1d(nr_b, size=3), color=OBS_B,  lw=1.5, alpha=0.75, label='Obs B null ratio')
ax0.plot(wc, uniform_filter1d(res['kalman_ratio'],size=3), color=VIOLET, lw=0.8, alpha=0.4, label='Kalman')
if g.gate_floor:
    ax0.axhline(g.gate_floor,    color=GREEN, lw=1.4, ls='--', label=f'floor={g.gate_floor:.2f}')
    ax0.axhline(g.baseline_mean, color=WH,    lw=0.7, ls=':', alpha=0.5)
for ec in res['ec_single']: ax0.axvline(ec, color=GOLD,  lw=1.0, alpha=0.7)
for ec in res['ec_cc']:     ax0.axvline(ec, color=ROSE,  lw=1.2, alpha=0.8, ls=':')
ax0.set_xlabel("Cycle",fontsize=8); ax0.set_ylabel("Windowed Null Ratio",fontsize=8)
ax0.set_title("Null Ratio — Obs A (teal) · Obs B (blue)\nyellow=single event · pink=cc event",color=FG,fontsize=8)
ax0.legend(fontsize=6,facecolor='#0d0f18',edgecolor='none',loc='upper right',ncol=2)
ax0.grid(True,alpha=0.08); ax0.tick_params(labelsize=6); ax0.set_xlim(0,N_cycles)

# ── [0,1] Cross-correlation timeseries ──
ax1 = fig.add_subplot(gs[0,1]); ax1.set_facecolor(BG)
span(ax1)
if len(cc_all)==len(wc):
    ax1.plot(wc, uniform_filter1d(cc_all, size=3), color=GOLD, lw=1.8, label='cross-corr r(A,B)')
if cc.gate_ceil is not None:
    ax1.axhline(cc.gate_ceil,      color=ROSE, lw=1.4, ls='--', label=f'ceil={cc.gate_ceil:.3f}')
    ax1.axhline(cc.baseline_mean,  color=WH,   lw=0.7, ls=':', alpha=0.5)
ax1.axhline(0, color=DIM, lw=0.8)
for ec in res['ec_cc']: ax1.axvline(ec, color=ROSE, lw=1.2, alpha=0.8, ls=':')
ax1.set_xlabel("Cycle",fontsize=8); ax1.set_ylabel("Pearson r (lag 0)",fontsize=8)
ax1.set_title("Cross-Correlation A×B\n≈0 background · rises during confinement · decays recovery",
              color=FG,fontsize=8)
ax1.legend(fontsize=6,facecolor='#0d0f18',edgecolor='none')
ax1.grid(True,alpha=0.08); ax1.tick_params(labelsize=6); ax1.set_xlim(0,N_cycles)

# ── [1,0] 3D joint hull scatter — the key panel ──
ax2 = fig.add_subplot(gs[1,0], projection='3d'); ax2.set_facecolor(BG)
# Subsample for readable scatter
def sub(arr, n=600):
    if len(arr) <= n: return arr
    idx=np.linspace(0,len(arr)-1,n,dtype=int); return arr[idx]

hp_bg    = sub(res['hp_bg'])
hp_burst = sub(res['hp_burst'])
hp_rec   = sub(res['hp_rec'])

ax2.scatter(hp_bg[:,0],    hp_bg[:,1],    hp_bg[:,2],    c=TEAL,    s=4, alpha=0.35, label='background')
ax2.scatter(hp_burst[:,0], hp_burst[:,1], hp_burst[:,2], c=BURST_C, s=7, alpha=0.65, label='burst')
ax2.scatter(hp_rec[:,0],   hp_rec[:,1],   hp_rec[:,2],   c=VIOLET,  s=4, alpha=0.35, label='recovery')

# Draw burst hull if it collapsed
if res['hull_bu'] is not None:
    hull_pts_sub = sub(res['hp_burst'])
    try:
        h2=ConvexHull(hull_pts_sub)
        step=max(len(h2.simplices)//200,1)
        poly=Poly3DCollection([hull_pts_sub[s] for s in h2.simplices[::step]],
                              alpha=0.10,linewidth=0.3)
        poly.set_facecolor(BURST_C); poly.set_edgecolor(BURST_C); ax2.add_collection3d(poly)
    except: pass

ax2.legend(fontsize=6,facecolor='#0d0f18',edgecolor='none',loc='upper left')
style_3d(ax2,"x_a_meas","x_b_meas","corr",
         f"Joint Hull: (x_a, x_b, corr)  bg={res['shape_bg']}→burst={res['shape_bu']}\n"
         f"bg_e1={pca_bg[0]:.3f}  burst_e1={pca_bu[0]:.3f}")
ax2.view_init(elev=25, azim=-50)

# ── [1,1] Joint distribution scatter x_a vs x_b by phase ──
ax3 = fig.add_subplot(gs[1,1]); ax3.set_facecolor(BG)
ax3.scatter(res['hp_bg'][:,0],    res['hp_bg'][:,1],    c=TEAL,    s=4, alpha=0.25, label='background')
ax3.scatter(res['hp_burst'][:,0], res['hp_burst'][:,1], c=BURST_C, s=8, alpha=0.60, label='burst')
ax3.scatter(res['hp_rec'][:,0],   res['hp_rec'][:,1],   c=VIOLET,  s=4, alpha=0.25, label='recovery')
# Diagonal reference
lims=np.array([min(ax3.get_xlim()[0],ax3.get_ylim()[0]),
               max(ax3.get_xlim()[1],ax3.get_ylim()[1])])
ax3.plot(lims,lims,color=WH,lw=0.8,ls=':',alpha=0.4,label='x_a=x_b diagonal')
ax3.set_xlabel("x_a measurement",fontsize=8); ax3.set_ylabel("x_b measurement",fontsize=8)
ax3.set_title("Joint Distribution: x_a vs x_b by phase\nburst clusters toward diagonal (shared confinement)",
              color=FG,fontsize=8)
ax3.legend(fontsize=6,facecolor='#0d0f18',edgecolor='none')
ax3.grid(True,alpha=0.08); ax3.tick_params(labelsize=6)

# ── [2,0] Hull volume over time ──
ax4 = fig.add_subplot(gs[2,0]); ax4.set_facecolor(BG)
# Build per-window volume log from joint hull
# We need to recompute using stored hull pts (grouped by window)
vol_log=[]; vol_cycles=[]
all_pts = np.vstack([res['hp_bg'], res['hp_burst'], res['hp_rec']])
all_ph  = (['bg']*len(res['hp_bg']) + ['burst']*len(res['hp_burst'])
           + ['rec']*len(res['hp_rec']))
# Use the cc_all array length (one per window) to approximate
# Actually: approximate by using per-phase volumes across cycles
# Easier: use raw NR log cycles with per-phase phase flag
bg_vol   = [res['v_bg']  ]*sum(ph=='bg')
bu_vol   = [res['v_bu']  ]*sum(ph=='burst')
rec_vol  = [res['v_rec'] ]*sum(ph=='rec')
vol_approx = np.array(bg_vol + bu_vol + rec_vol)
ax4.axvspan(0,N_background,color='#1a3040',alpha=0.35,label='background')
ax4.axvspan(N_background,N_background+N_burst,color=BURST_C,alpha=0.12,label='burst')
ax4.axvspan(N_background+N_burst,N_cycles,color='#1a2830',alpha=0.25,label='recovery')
# Show as horizontal segments with actual values
ax4.axhline(res['v_bg'],  color=TEAL,    lw=2, label=f"bg  vol={res['v_bg']:.2f}",  xmin=0, xmax=N_background/N_cycles)
ax4.axhline(res['v_bu'],  color=BURST_C, lw=2, label=f"burst vol={res['v_bu']:.2f}", xmin=N_background/N_cycles, xmax=(N_background+N_burst)/N_cycles)
ax4.axhline(res['v_rec'], color=VIOLET,  lw=2, label=f"rec  vol={res['v_rec']:.2f}",  xmin=(N_background+N_burst)/N_cycles, xmax=1.0)
ax4.set_xlabel("Cycle",fontsize=8); ax4.set_ylabel("Hull Volume",fontsize=8)
ax4.set_title("Hull Volume by Phase (joint state)\nburst collapse = volume decrease",color=FG,fontsize=8)
ax4.legend(fontsize=6,facecolor='#0d0f18',edgecolor='none')
ax4.grid(True,alpha=0.08); ax4.tick_params(labelsize=6); ax4.set_xlim(0,N_cycles)

# ── [2,1] PCA eigenvalue bars ──
ax5 = fig.add_subplot(gs[2,1]); ax5.set_facecolor(BG)
x_pos   = np.arange(3)
bar_w   = 0.25
phases  = [('bg',   TEAL,    pca_bg),
           ('burst',BURST_C, pca_bu),
           ('rec',  VIOLET,  pca_rec)]
offsets = [-bar_w, 0, bar_w]
for (lbl, col, pca), off in zip(phases, offsets):
    ax5.bar(x_pos+off, pca, bar_w, color=col, alpha=0.8, label=lbl,
            edgecolor=col, linewidth=0.5)
ax5.set_xticks(x_pos); ax5.set_xticklabels(['e₁ (dominant)','e₂','e₃'],fontsize=7)
ax5.set_ylabel("Explained Variance Ratio",fontsize=8)
ax5.set_title("PCA Eigenvalue Distribution by Phase\nburst e₁→1 = collapse to single axis (LINEAR)",
              color=FG,fontsize=8)
ax5.axhline(0.7,color=WH,lw=0.8,ls=':',alpha=0.5,label='dominant threshold=0.7')
ax5.legend(fontsize=6,facecolor='#0d0f18',edgecolor='none')
ax5.grid(True,alpha=0.08,axis='y'); ax5.tick_params(labelsize=6)
ax5.set_ylim(0,1)

plt.savefig(FIG_PATH, dpi=150, bbox_inches='tight', facecolor=BG)
plt.show(); print(" done.")
print(f"  Figure saved to: {FIG_PATH}")

# ─── FINAL SUMMARY ────────────────────────────────────────────────────────────
print()
print("="*70)
print("SFE-06.2  —  Joint Observer Geometry · Hull Shape")
print("="*70)
print()
print("BACKEND")
print(f"  matplotlib_backend = {matplotlib.get_backend()}")
print(f"  figure_saved_to    = {FIG_PATH}")
print()
print("VARIANCE FIX")
print(f"  bg_var_a (own origin) = {bg_var_a:.2f}")
print(f"  bg_var_b (own origin) = {bg_var_b:.2f}")
print(f"  variance_symmetric    = {'yes' if var_symmetric else f'no  (ratio={var_ratio:.2f})'}")
print()
print("HULL GEOMETRY")
print(f"  background_shape  = {res['shape_bg']}")
print(f"  burst_shape       = {res['shape_bu']}")
print(f"  recovery_shape    = {res['shape_rec']}")
print(f"  background_volume = {res['v_bg']:.4f}")
print(f"  burst_volume      = {res['v_bu']:.4f}")
print(f"  recovery_volume   = {res['v_rec']:.4f}")
print()
print("PCA EIGENVALUES")
print(f"  background: [{pca_bg[0]:.3f}, {pca_bg[1]:.3f}, {pca_bg[2]:.3f}]")
print(f"  burst:      [{pca_bu[0]:.3f}, {pca_bu[1]:.3f}, {pca_bu[2]:.3f}]")
print(f"  recovery:   [{pca_rec[0]:.3f}, {pca_rec[1]:.3f}, {pca_rec[2]:.3f}]")
print()
print("CROSS-CORRELATION (unchanged from SFE-06)")
print(f"  corr_events_burst      = {len(res['cc_burst'])}")
print(f"  corr_events_background = {len(res['cc_bg_ev'])}")
print(f"  corr_max_burst         = {res['cc_burst_max']:.4f}")
print(f"  cc_detects_earlier     = {res['cc_detects_earlier']}")
print()
print("SUCCESS")
print(f"  variance_symmetric:        {'PASS ✓' if s3 else 'FAIL ✗'}  (ratio={var_ratio:.2f})")
print(f"  bg_hull_volumetric:        {'PASS ✓' if s4 else 'FAIL ✗'}  ({res['shape_bg']})")
print(f"  burst_hull_collapsed:      {'PASS ✓' if s5 else 'FAIL ✗'}  ({res['shape_bu']})")
print(f"  burst_eigenvalue_dominant: {'PASS ✓' if s6 else 'FAIL ✗'}  ({pca_bu[0]:.3f} ≥ 0.65)")
print(f"  corr_events_burst > 0:     {'PASS ✓' if s1 else 'FAIL ✗'}  ({len(res['cc_burst'])})")
print(f"  corr_events_bg = 0:        {'PASS ✓' if s2 else 'FAIL ✗'}  ({len(res['cc_bg_ev'])})")
print()
print("="*70)
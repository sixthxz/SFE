# -*- coding: utf-8 -*-
"""SFE-05.13b

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1GaJXZGYS1rB8v4YCbW8mshBnXVBS-P7s
"""

# Commented out IPython magic to ensure Python compatibility.
# -*- coding: utf-8 -*-
"""
SFE-05.13b — Change Detection · Null Predictor · OU Burst
===========================================================
Root cause: Kalman floor-lock. With good tracking, innov≈sigma_m*noise always.
Fix: Use NULL PREDICTOR for coherence metric — innov_null = |z - 0| = |x_meas|
  During free diffusion: <|x_meas|> large (particle wanders)
  During OU burst:       <|x_meas|> small (particle confined near 0)
  Separation: ~4.4 window std devs

Kalman still runs (for state estimation + speed modulation), but
coherence signal = |z_t| / field_vol (not Kalman innovation).

Gate: coherence when null_ratio DROPS below baseline_mean - z_sigma*baseline_std
"""

import numpy as np
import matplotlib
# %matplotlib inline
import matplotlib.pyplot as plt
from matplotlib.gridspec import GridSpec
from mpl_toolkits.mplot3d.art3d import Poly3DCollection
from matplotlib.lines import Line2D
from scipy.spatial import ConvexHull, QhullError
from scipy.ndimage import uniform_filter1d
import warnings; warnings.filterwarnings('ignore')
np.random.seed(42)
import os; FIG_DIR = '/tmp/sfe0513b_figs'; os.makedirs(FIG_DIR, exist_ok=True)

print("="*70)
print("SFE-05.13b  —  Change Detection · Null Predictor · OU Burst")
print("="*70)

kBT=1.0; gamma=1.0; D_diff=kBT/gamma
dt=0.01; tau_meas=10
x_min,x_max=-8.0,8.0; Nx=400
x_grid=np.linspace(x_min,x_max,Nx); dx=x_grid[1]-x_grid[0]

sigma_m          = 0.40
field_volatility = np.sqrt(2*D_diff*tau_meas*dt)   # normalization

# Phase structure
N_background = 1000
N_burst      = 200
N_recovery   = 200
N_cycles     = N_background + N_burst + N_recovery

k_background = 0.0
k_signal     = 1.0
z_sigma      = 1.5
COHERENCE_WIN = 40

# Other params
BUFFER_N=512; anomaly_buf_size=256; gate_multiplier=1.0; gate_window=50
min_core_rate=0.20; coherence_var_th=0.15; alpha_attract=0.15
min_events_before=10; n_candidates=5; rehearsal_on=True
dt_coherent=dt; dt_surprised=dt*0.5
lambda_coup_init=0.30; lambda_min=0.05; lambda_max=0.80
sigma_memory=1.20; x0=0.0; window_scale=1.0
N_steps = N_cycles * tau_meas

# Theory
Var_x_bg_theory    = 5.0   # approximate bounded diffusion variance
Var_x_burst_theory = kBT/k_signal
E_bg    = np.sqrt(2/np.pi)*np.sqrt(Var_x_bg_theory + sigma_m**2)/field_volatility
E_burst = np.sqrt(2/np.pi)*np.sqrt(Var_x_burst_theory + sigma_m**2)/field_volatility
std_bg_win = np.sqrt(1-2/np.pi)*np.sqrt(Var_x_bg_theory+sigma_m**2)/field_volatility / np.sqrt(COHERENCE_WIN)
sep_sigma = (E_bg - E_burst) / std_bg_win

print(f"\n  sigma_m={sigma_m}  field_vol={field_volatility:.4f}")
print(f"  Background: {N_background} cyc (k=0)  →  Burst: {N_burst} cyc (k={k_signal})  →  Recovery: {N_recovery} cyc (k=0)")
print(f"  COHERENCE METRIC: null predictor — |z_t| (position-based, not Kalman)")
print(f"  Gate: ratio DROPS below baseline - {z_sigma}*std (confinement = lower surprise)")
print(f"\n  Theory: bg_ratio~{E_bg:.2f}  burst_ratio~{E_burst:.2f}  separation~{sep_sigma:.1f}σ")
print()

# ─── HELPERS ──────────────────────────────────────────────────────────────────
def _gr(m,s):
    r=np.exp(-0.5*((x_grid-m)/s)**2); return r/np.trapezoid(r,x_grid)

def fp_step(rho, F, k=0., x0w=0.):
    Ft=F-k*(x_grid-x0w); N_=len(rho)
    v=Ft/gamma; df=np.zeros(N_+1); ff=np.zeros(N_+1)
    for i in range(1,N_):
        vf=0.5*(v[i-1]+v[i])
        df[i]=vf*rho[i-1] if vf>=0 else vf*rho[i]
        ff[i]=D_diff*(rho[i]-rho[i-1])/dx
    rn=np.maximum(rho-(dt/dx)*np.diff(df-ff),0.)
    nm=np.trapezoid(rn,x_grid); return rn/nm if nm>1e-12 else rn

def fp_flux(rho, F):
    return (F/gamma)*rho - D_diff*np.gradient(rho,x_grid)

def compute_alignment(xp, rt, rp):
    gt=float(np.interp(xp,x_grid,np.gradient(rt,x_grid)))
    gp=float(np.interp(xp,x_grid,np.gradient(rp,x_grid)))
    if abs(gt)<1e-10 or abs(gp)<1e-10: return 0.
    return float(np.clip(gt*gp/(abs(gt)*abs(gp)),-1.,1.))

def convex_hull_3d(pts):
    if len(pts)<5: return 0.,0.,None
    try: h=ConvexHull(pts); return h.volume,h.area,h
    except QhullError: return 0.,0.,None

def pca_axes(pts):
    if len(pts)<4: return np.array([1.,0.,0.]),np.eye(3)
    c=pts-pts.mean(0); cov=np.cov(c.T)
    if cov.ndim<2: return np.array([1.,0.,0.]),np.eye(3)
    vals,vecs=np.linalg.eigh(cov)
    order=np.argsort(vals)[::-1]; vals=np.maximum(vals[order],0.); vecs=vecs[:,order]
    return vals/(vals.sum()+1e-12), vecs.T

def classify_geometry(pca_ratio):
    v0,v1,v2=pca_ratio
    if v0>0.70:   return "LINEAR"
    elif v0>0.50: return "PLANAR"
    elif v2>0.25: return "VOLUMETRIC"
    else:         return "PLANAR"

# ─── CLASSES ──────────────────────────────────────────────────────────────────
class CircularBuffer:
    def __init__(self,N,cols=3):
        self.N=N; self.cols=cols
        self.buf=np.zeros((N,cols),dtype=np.float32); self.filled=self.writes=0
    def push(self,row):
        self.writes+=1; self.buf=np.roll(self.buf,shift=1,axis=0)
        self.buf[0]=np.array(row,dtype=np.float32); self.filled=min(self.filled+1,self.N)
    def get_numpy(self): return self.buf[:self.filled]
    def normalize(self):
        d=self.get_numpy()
        if len(d)<4: return d,np.zeros(self.cols),np.ones(self.cols)
        mu=d.mean(0); sig=d.std(0)+1e-8; return (d-mu)/sig,mu,sig

class AdaptiveGate:
    def __init__(self,mult,window,floor):
        self.mult=mult; self.window=window; self.floor=floor; self._h=[]; self.threshold=floor
    def update(self,s):
        self._h.append(s)
        if len(self._h)>self.window: self._h.pop(0)
        if len(self._h)>=4:
            self.threshold=max(float(np.std(self._h))*self.mult,self.floor)
        return self.threshold
    def core_gate(self,s): return s<=self.threshold
    def anomaly_gate(self,s): return s>self.threshold

class KalmanOU:
    """Standard Kalman for state estimation only. No freeze needed."""
    def __init__(self, k=0.0):
        self.k=k; self.x_hat=0.0; self.P=2*kBT/gamma*tau_meas*dt
    def predict_n(self, n):
        if self.k==0.0: self.P+=n*2*kBT/gamma*dt
        else:
            a=np.exp(-self.k*dt*n); sou=kBT/self.k; self.x_hat*=a
            self.P=self.P*a**2+sou*(1-a**2)
    def update(self, z):
        Pp=self.P; K=self.P/(self.P+sigma_m**2)
        inn=z-self.x_hat; self.x_hat+=K*inn; self.P*=(1-K)
        return Pp, abs(inn)

class PerceivedField:
    def __init__(self,mx=300): self.s=[]; self.w=[]; self.mx=mx
    def add(self,xp,w=1.0):
        self.s.append(xp); self.w.append(w)
        if len(self.s)>self.mx: self.s.pop(0); self.w.pop(0)
    def get_rho(self):
        if len(self.s)<2: return _gr(0.,1.)
        rho=np.zeros(Nx); wt=sum(self.w)
        for xp,w in zip(self.s,self.w):
            rho+=(w/wt)*np.exp(-0.5*((x_grid-xp)/sigma_memory)**2)
        nm=np.trapezoid(rho,x_grid); return rho/nm if nm>1e-12 else rho

class CoherenceCentroid:
    def __init__(self): self.centroid=np.zeros(3); self.n=0
    def update(self,pos):
        self.n+=1; self.centroid=((self.n-1)*self.centroid+pos)/self.n
        return self.centroid.copy()
    def attraction_force_x(self,c):
        return alpha_attract*(self.centroid[0]-c) if self.n>0 else 0.
    @property
    def is_ready(self): return self.n>=min_events_before
    @property
    def position(self): return self.centroid.copy()


class NullPredictorGate:
    """
    Coherence metric: null_ratio = |z_t| / field_vol (not Kalman innovation).
    Baseline built from background windows of windowed null_ratio.
    Gate: coherence when windowed null_ratio < baseline_mean - z_sigma*baseline_std.
    """
    def __init__(self, z_sig):
        self.z_sig=z_sig
        self._bg_win_ratios=[]
        self._all_win_ratios=[]
        self.baseline_mean=None; self.baseline_std=None; self.gate_floor=None
        self.frozen=False
        self.n_crossings=0; self.n_verified=0; self.n_rejected=0

    def push_background(self, win_null_ratio):
        self._bg_win_ratios.append(win_null_ratio)
        self._all_win_ratios.append(win_null_ratio)

    def freeze(self):
        self.baseline_mean=float(np.mean(self._bg_win_ratios))
        self.baseline_std =float(np.std(self._bg_win_ratios))+1e-8
        self.gate_floor   =self.baseline_mean - self.z_sig*self.baseline_std
        self.frozen=True
        return self.baseline_mean, self.baseline_std, self.gate_floor

    def push_active(self, win_null_ratio):
        self._all_win_ratios.append(win_null_ratio)

    def check(self, win_null_ratio, rv, core_rate, pts, cycle):
        if not self.frozen: return False, False, float('nan')
        delta = win_null_ratio - self.gate_floor
        crossing = (win_null_ratio < self.gate_floor)
        if crossing:
            self.n_crossings += 1
            prev = self._all_win_ratios[-2] if len(self._all_win_ratios)>=2 else win_null_ratio
            verified = (prev < self.gate_floor)
            if verified: self.n_verified += 1
            else: self.n_rejected += 1
            struct_ok = (rv < coherence_var_th) and (core_rate >= min_core_rate)
            if verified and struct_ok and len(pts)>=5:
                return True, True, delta
        return False, False, delta

    @property
    def verif_pass_rate(self): return self.n_verified/max(self.n_crossings,1)
    @property
    def verif_reject_rate(self): return self.n_rejected/max(self.n_crossings,1)
    @property
    def all_win_ratios(self): return np.array(self._all_win_ratios)


# ─── MAIN RUN ─────────────────────────────────────────────────────────────────
def run():
    rng=np.random.default_rng(42); kf=KalmanOU(k=k_background); pf=PerceivedField()
    cb=CircularBuffer(BUFFER_N); ab=CircularBuffer(anomaly_buf_size)
    wg=AdaptiveGate(gate_multiplier,gate_window,floor=field_volatility)
    cen=CoherenceCentroid(); gate=NullPredictorGate(z_sigma)
    rho=_gr(0.,2.); F0=np.zeros(Nx); x=0.; pf.add(x)
    lam=lambda_coup_init; cur_sr=2.; campo_last=0.

    null_ratio_log=[]; win_cycle_log=[]; phase_log=[]
    kalman_ratio_log=[]; events=[]; event_cycles=[]; centroid_hist=[]
    snap_va={}; snap_at={N_steps//8:'early',N_steps//2:'mid',7*N_steps//8:'late'}
    vw=[]; null_sw=[]; kalman_sw=[]; total=0; cw=0; aw=0; cycle=0
    baseline_frozen=False

    for i in range(N_steps):
        if cycle < N_background:      phase='bg';    k_now=k_background
        elif cycle < N_background+N_burst: phase='burst'; k_now=k_signal
        else:                          phase='rec';   k_now=k_background
        kf.k=k_now

        if i%tau_meas==0:
            kf.predict_n(tau_meas)
            xm=x+sigma_m*rng.standard_normal()
            P_prior,kalman_innov=kf.update(xm)

            # NULL PREDICTOR coherence metric
            null_innov=abs(xm)   # |z - 0|

            rp=pf.get_rho(); aln=compute_alignment(x,rho,rp)
            J=fp_flux(rho,F0); campo=float(abs(np.interp(x,x_grid,J))); campo_last=campo
            cur_sr=kalman_innov/(field_volatility+1e-10)   # for speed modulation

            wg.update(kalman_innov); total+=1
            if wg.core_gate(kalman_innov): cb.push([campo,aln,null_innov]); cw+=1
            if wg.anomaly_gate(kalman_innov): ab.push([campo,aln,null_innov]); aw+=1

            null_sw.append(null_innov); kalman_sw.append(kalman_innov)
            if len(null_sw)>COHERENCE_WIN: null_sw.pop(0); kalman_sw.pop(0)
            cycle+=1

            if cycle%COHERENCE_WIN==0 and cb.filled>=5:
                T,_,_=cb.normalize(); v,a,_=convex_hull_3d(T); vw.append(v)
                wl=max(int(N_cycles*0.5*window_scale),8)
                if len(vw)>wl: vw.pop(0)
                core_rate=cw/max(total,1)
                if len(vw)>=3:
                    vm=np.mean(vw); vs=np.std(vw)+1e-8; z=(v-vm)/vs
                    if z>1.: lam=min(lam*1.05,lambda_max)
                    elif z<-0.5: lam=max(lam*0.98,lambda_min)

                ms_null=float(np.mean(null_sw)); win_null_ratio=ms_null/(field_volatility+1e-10)
                ms_kalman=float(np.mean(kalman_sw)); win_kalman_ratio=ms_kalman/(field_volatility+1e-10)
                mv=np.mean(vw)+1e-8; rv=float(np.var(vw))/(mv**2)

                null_ratio_log.append(win_null_ratio); win_cycle_log.append(cycle)
                kalman_ratio_log.append(win_kalman_ratio); phase_log.append(phase)

                if phase=='bg':
                    gate.push_background(win_null_ratio)
                else:
                    if not baseline_frozen:
                        bl_m,bl_s,gf=gate.freeze(); baseline_frozen=True
                        print(f"\n  ▸ FREEZE at cycle={cycle}")
                        print(f"    null baseline={bl_m:.4f}±{bl_s:.4f}  gate_floor={gf:.4f}")
                        print(f"    (theory: bg~{E_bg:.2f}  burst~{E_burst:.2f}  sep={sep_sigma:.1f}σ)\n")
                    gate.push_active(win_null_ratio)
                    ms_raw=cb.get_numpy().mean(0)
                    is_ev,verified,delta=gate.check(win_null_ratio,rv,core_rate,T,cycle)
                    if is_ev:
                        ve,ae,he=convex_hull_3d(T); re,axe=pca_axes(T); ctype=classify_geometry(re)
                        cen.update(ms_raw)
                        ev=dict(cycle=cycle,phase=phase,null_ratio=win_null_ratio,
                                kalman_ratio=win_kalman_ratio,delta=delta,vol=ve,
                                area=ae,hull=he,pts=T.copy(),pca_ratio=re,pca_axes=axe,
                                rel_var=rv,ctype=ctype,lam=lam,core_rate=core_rate,
                                centroid=cen.position.copy())
                        events.append(ev); event_cycles.append(cycle)
                        centroid_hist.append(cen.position.copy())
                        print(f"      ★ c={cycle:4d} [{phase:5s}] null_r={win_null_ratio:.4f} "
                              f"floor={gate.gate_floor:.4f} δ={delta:+.4f} "
                              f"vol={ve:.1f} type={ctype} core={core_rate:.3f}")

        dt_eff=dt_coherent if cur_sr<1.0 else dt_surprised
        J=fp_flux(rho,F0); Jat=float(np.interp(x,x_grid,J))
        Ff=lam*Jat/(abs(Jat)+1e-10); Fou=-k_now*(x-x0)
        Fatt=cen.attraction_force_x(campo_last) if cen.is_ready else 0.
        def step(Fe):
            xi=np.sqrt(2*kBT*gamma)*rng.standard_normal()
            return float(np.clip(x+((Ff+Fe)/gamma)*dt_eff+xi*np.sqrt(dt_eff)/gamma,x_min+.1,x_max-.1))
        xs=step(Fatt+Fou); bs=abs(xs-kf.x_hat); bx=xs
        if rehearsal_on and n_candidates>1:
            for _ in range(n_candidates-1):
                xc=step(Fatt+Fou); sc=abs(xc-kf.x_hat)
                if sc<bs: bx=xc; bs=sc
        rho=fp_step(rho,F0,k_now,x0); pf.add(bx,w=1./(sigma_m+.1)); x=bx
        if i in snap_at:
            T2,_,_=cb.normalize(); lbl=snap_at[i]; v2,a2,h2=convex_hull_3d(T2)
            snap_va[lbl]=(v2,a2,h2,T2.copy())

    T,_,_=cb.normalize(); v,a,h=convex_hull_3d(T); snap_va['final']=(v,a,h,T.copy())
    nr=np.array(null_ratio_log); kr=np.array(kalman_ratio_log)
    ph=np.array(phase_log); wc=np.array(win_cycle_log)

    bg_m=nr[ph=='bg'];    bg_mean=float(bg_m.mean()) if len(bg_m) else float('nan')
    bu_m=nr[ph=='burst']; burst_mean=float(bu_m.mean()) if len(bu_m) else float('nan')
    burst_min=float(bu_m.min()) if len(bu_m) else float('nan')
    rec_m=nr[ph=='rec'];  rec_mean=float(rec_m.mean()) if len(rec_m) else float('nan')
    sigma_below=(gate.baseline_mean-burst_min)/gate.baseline_std if gate.baseline_std and burst_min else float('nan')

    return dict(events=events,
        events_burst=[e for e in events if e['phase']=='burst'],
        events_bg=[e for e in events if e['phase']=='bg'],
        events_rec=[e for e in events if e['phase']=='rec'],
        event_cycles=event_cycles, centroid_hist=centroid_hist,
        gate=gate, cen=cen,
        null_ratio_log=nr, kalman_ratio_log=kr,
        win_cycle_log=wc, phase_log=ph,
        bg_mean=bg_mean, burst_mean=burst_mean, burst_min=burst_min,
        rec_mean=rec_mean, sigma_below=sigma_below,
        snap_va=snap_va, buf_final=T, lam_final=lam, core_rate=cw/max(total,1))


print(f"{'─'*70}")
print(f"Run: background(k=0,{N_background}cyc) → burst(k={k_signal},{N_burst}cyc) → recovery(k=0,{N_recovery}cyc)")
print(f"{'─'*70}")
res=run(); g=res['gate']

print()
print("="*70); print("SFE-05.13b  Results"); print("="*70)
print(f"\n  PHASE STRUCTURE (null_ratio = |x_meas| / field_vol)")
print(f"    background:  ratio={res['bg_mean']:.4f}")
print(f"    burst:       ratio={res['burst_mean']:.4f}  min={res['burst_min']:.4f}")
print(f"    recovery:    ratio={res['rec_mean']:.4f}")
print()
print(f"  BASELINE")
print(f"    mean={g.baseline_mean:.4f}  std={g.baseline_std:.4f}  gate_floor={g.gate_floor:.4f}")
print(f"    sigma_below (burst min) = {res['sigma_below']:.2f}σ")
print()
print(f"  BURST DETECTION")
print(f"    events_in_burst      = {len(res['events_burst'])}")
print(f"    events_in_background = {len(res['events_bg'])}")
print(f"    events_in_recovery   = {len(res['events_rec'])}")
if res['events_burst']:
    tc={}
    for e in res['events_burst']: tc[e['ctype']]=tc.get(e['ctype'],0)+1
    print(f"    first burst event at cycle {res['events_burst'][0]['cycle']}")
    print(f"    types: {tc}")
print()
print(f"  VERIFICATION  cross={g.n_crossings}  verif={g.n_verified}  rej={g.n_rejected}  rej_rate={g.verif_reject_rate:.3f}")
print()
print(f"  SUCCESS CHECK")
r1=len(res['events_burst'])>0; r2=len(res['events_bg'])==0
r3=len(res['events_rec'])==0;  r4=res['sigma_below']>=2.0
print(f"    events_in_burst > 0:      {'PASS ✓' if r1 else 'FAIL ✗'}  ({len(res['events_burst'])})")
print(f"    events_in_background = 0: {'PASS ✓' if r2 else 'FAIL ✗'}  ({len(res['events_bg'])})")
print(f"    events_in_recovery = 0:   {'PASS ✓' if r3 else 'FAIL ✗'}  ({len(res['events_rec'])})")
print(f"    sigma_below ≥ 2.0:        {'PASS ✓' if r4 else 'FAIL ✗'}  ({res['sigma_below']:.2f}σ)")

# ─── FIGURE ───────────────────────────────────────────────────────────────────
BG='#07080f'; FG='#dde1ec'; GOLD='#f5c842'; TEAL='#3dd6c8'; VIOLET='#b87aff'
ROSE='#ff5f7e'; GREEN='#4ade80'; AMBER='#fb923c'; COH='#fde68a'; DIM='#1e2235'; WH='#ffffff'
BURST_C='#ff8c42'

plt.rcParams.update({'figure.facecolor':BG,'axes.facecolor':BG,'axes.edgecolor':DIM,
    'text.color':FG,'axes.labelcolor':FG,'xtick.color':'#555870','ytick.color':'#555870'})

def draw_hull(ax,pts,hull,fc,ec,af=0.10,ae=0.28):
    if hull is None: return
    step=max(len(hull.simplices)//300,1)
    poly=Poly3DCollection([pts[s] for s in hull.simplices[::step]],alpha=af,linewidth=0.3)
    poly.set_facecolor(fc); poly.set_edgecolor(ec); ax.add_collection3d(poly)

def style_3d(ax,xl,yl,zl,t):
    ax.set_xlabel(xl,fontsize=8,labelpad=10); ax.set_ylabel(yl,fontsize=8,labelpad=10)
    ax.set_zlabel(zl,fontsize=8,labelpad=10); ax.set_title(t,color=FG,fontsize=8,pad=6)
    ax.tick_params(labelsize=6)
    for p in [ax.xaxis.pane,ax.yaxis.pane,ax.zaxis.pane]: p.fill=False; p.set_edgecolor(DIM)
    ax.grid(True,alpha=0.09)

tcc={}
for e in res['events_burst']: tcc[e['ctype']]=tcc.get(e['ctype'],0)+1
ev0=res['events_burst'][0] if res['events_burst'] else None
coh_state='COHERENT' if r1 else 'EXPLORING'

print(f"\nRendering figure...", end='', flush=True)
fig=plt.figure(figsize=(20,14),facecolor=BG)
gs=GridSpec(2,3,figure=fig,hspace=0.50,wspace=0.40,top=0.93,bottom=0.07,left=0.06,right=0.97)
fig.suptitle(
    f"SFE-05.13b  ·  Null Predictor  ·  OU Burst k={k_signal}\n"
    f"state={coh_state}  burst_events={len(res['events_burst'])}  "
    f"bg_events={len(res['events_bg'])}  σ_below={res['sigma_below']:.2f}σ  floor={g.gate_floor:.3f}",
    fontsize=11,color=GOLD,fontweight='bold')

ax0=fig.add_subplot(gs[0,:2],projection='3d'); ax0.set_facecolor(BG)
pts_f=res['buf_final']; _,_,hf=convex_hull_3d(pts_f)
sc=ax0.scatter(pts_f[:,0],pts_f[:,1],pts_f[:,2],c=np.linspace(0,1,len(pts_f)),cmap='plasma',s=6,alpha=0.70,linewidths=0)
draw_hull(ax0,pts_f,hf,TEAL,TEAL,0.06,0.18)
for ev_i in res['events_burst'][:4]: draw_hull(ax0,ev_i['pts'],ev_i['hull'],COH,COH,0.22,0.55)
cen_pos=res['cen'].position
if res['cen'].n>=min_events_before:
    ax0.scatter(*cen_pos,color=WH,s=180,marker='*',zorder=15)
    cm=pts_f.mean(0); ax0.quiver(*cm,*(cen_pos-cm),color=GOLD,lw=2.,alpha=0.80,arrow_length_ratio=0.20)
plt.colorbar(sc,ax=ax0,shrink=0.40,pad=0.04).set_label('Time',color=FG,fontsize=7)
style_3d(ax0,"Campo |J|","Alignment","|x_meas| (null surp)",
         f"Core Buffer  burst_events={len(res['events_burst'])}  types={tcc}\n"
         f"bg_null_ratio={res['bg_mean']:.3f}  burst={res['burst_mean']:.3f}  σ_below={res['sigma_below']:.2f}")
ax0.view_init(elev=22,azim=-52)

ax1=fig.add_subplot(gs[0,2],projection='3d'); ax1.set_facecolor(BG)
snaps=res['snap_va']
for lbl,col,af,ae in [('early',ROSE,0.12,0.35),('final',TEAL,0.07,0.20)]:
    e=snaps.get(lbl)
    if e:
        ax1.scatter(e[3][:,0],e[3][:,1],e[3][:,2],c=col,s=3,alpha=0.35,linewidths=0)
        draw_hull(ax1,e[3],e[2],col,col,af,ae)
if ev0 and ev0['hull'] is not None:
    draw_hull(ax1,ev0['pts'],ev0['hull'],COH,COH,0.30,0.65)
hl=[Line2D([0],[0],marker='o',color='w',markerfacecolor=ROSE,ms=4,label=f"early"),
    Line2D([0],[0],marker='o',color='w',markerfacecolor=TEAL,ms=4,label=f"final")]
if ev0: hl.append(Line2D([0],[0],marker='*',color='w',markerfacecolor=COH,ms=7,label=f"burst [{ev0['ctype']}]"))
ax1.legend(handles=hl,fontsize=7,loc='upper left',facecolor='#0d0f18',edgecolor='none')
style_3d(ax1,"Campo","Alignment","|x_meas|","Hull Evolution: bg → burst")
ax1.view_init(elev=25,azim=-40)

ax2=fig.add_subplot(gs[1,0]); ax2.set_facecolor(BG)
nr=res['null_ratio_log']; wc2=res['win_cycle_log']
ax2.axvspan(0,N_background,color='#1a3040',alpha=0.4,label='background')
ax2.axvspan(N_background,N_background+N_burst,color=BURST_C,alpha=0.15,label='burst')
ax2.axvspan(N_background+N_burst,N_cycles,color='#1a2830',alpha=0.3,label='recovery')
nr_sm=uniform_filter1d(nr,size=3)
ax2.plot(wc2,nr_sm,color=TEAL,lw=1.8,zorder=5,label='null ratio (|x|/field_vol)')
ax2.plot(wc2,uniform_filter1d(res['kalman_ratio_log'],size=3),color=VIOLET,lw=1.0,alpha=0.6,label='kalman ratio')
if g.gate_floor:
    ax2.axhline(g.gate_floor,color=GREEN,lw=1.5,ls='--',label=f'gate_floor={g.gate_floor:.3f}')
    ax2.axhline(g.baseline_mean,color=WH,lw=0.8,ls=':',alpha=0.5,label=f'baseline={g.baseline_mean:.3f}')
for ec in res['event_cycles']: ax2.axvline(ec,color=COH,lw=1.0,alpha=0.7,ls='--')
ax2.set_xlabel("Cycle",fontsize=8); ax2.set_ylabel("Windowed Ratio",fontsize=8)
ax2.set_title("Null Predictor Ratio + Phase Gate\n(coherence = |x_meas| drops below baseline)",color=FG,fontsize=9)
ax2.legend(fontsize=6,facecolor='#0d0f18',edgecolor='none',loc='upper right',ncol=2)
ax2.grid(True,alpha=0.10); ax2.tick_params(labelsize=7); ax2.set_xlim(0,N_cycles)

ax3=fig.add_subplot(gs[1,1]); ax3.set_facecolor(BG)
raw_nr=np.array([abs(xm) for xm in []])  # placeholder
# Show per-phase ratio histogram
if len(res['null_ratio_log'])>0:
    bg_r  = res['null_ratio_log'][res['phase_log']=='bg']
    bu_r  = res['null_ratio_log'][res['phase_log']=='burst']
    rec_r = res['null_ratio_log'][res['phase_log']=='rec']
    bins=np.linspace(0,max(nr)*1.1,30)
    if len(bg_r): ax3.hist(bg_r,bins=bins,color=TEAL,alpha=0.6,label=f'bg n={len(bg_r)}')
    if len(bu_r): ax3.hist(bu_r,bins=bins,color=BURST_C,alpha=0.7,label=f'burst n={len(bu_r)}')
    if len(rec_r): ax3.hist(rec_r,bins=bins,color=VIOLET,alpha=0.5,label=f'rec n={len(rec_r)}')
    if g.gate_floor: ax3.axvline(g.gate_floor,color=GREEN,lw=1.5,ls='--',label=f'floor={g.gate_floor:.3f}')
    ax3.axvline(g.baseline_mean if g.baseline_mean else 0,color=WH,lw=0.8,ls=':',alpha=0.6)
ax3.set_xlabel("Windowed Null Ratio",fontsize=8); ax3.set_ylabel("Count",fontsize=8)
ax3.set_title("Distribution by Phase\n(burst should be left-shifted from bg)",color=FG,fontsize=9)
ax3.legend(fontsize=7,facecolor='#0d0f18',edgecolor='none')
ax3.grid(True,alpha=0.10); ax3.tick_params(labelsize=7)

tc_b={}
for e in res['events_burst']: tc_b[e['ctype']]=tc_b.get(e['ctype'],0)+1
slines=[
    "SFE-05.13b  Null Predictor","─"*30,
    f"coherence = |x_meas| / field_vol",
    f"gate = baseline - {z_sigma}*std","",
    f"k_bg={k_background}  k_sig={k_signal}",
    f"N_bg={N_background}  N_burst={N_burst}  N_rec={N_recovery}","",
    "BASELINE",
    f"  mean  = {g.baseline_mean:.4f}" if g.baseline_mean else "  (not set)",
    f"  std   = {g.baseline_std:.4f}" if g.baseline_std else "",
    f"  floor = {g.gate_floor:.4f}" if g.gate_floor else "","",
    "PHASES",
    f"  bg    = {res['bg_mean']:.4f}",
    f"  burst = {res['burst_mean']:.4f}",
    f"  min   = {res['burst_min']:.4f}",
    f"  σ_↓   = {res['sigma_below']:.2f}",
    f"  rec   = {res['rec_mean']:.4f}","",
    "EVENTS",
    f"  burst={len(res['events_burst'])}  bg={len(res['events_bg'])}  rec={len(res['events_rec'])}",
    f"  types: {tc_b}","",
    f"VERIF x={g.n_crossings} v={g.n_verified} r={g.n_rejected}","",
    "SUCCESS",
    f"  burst>0: {'✓' if r1 else '✗'}",
    f"  bg=0:    {'✓' if r2 else '✗'}",
    f"  rec=0:   {'✓' if r3 else '✗'}",
    f"  σ≥2:     {'✓' if r4 else '✗'} ({res['sigma_below']:.2f})",
    "","─"*30,f"STATE: {coh_state}"]
ax_sum=fig.add_subplot(gs[1,2]); ax_sum.axis('off')
ax_sum.text(0.04,0.97,"\n".join(slines),transform=ax_sum.transAxes,fontsize=7.5,
            fontfamily='monospace',color=FG,va='top',linespacing=1.4,
            bbox=dict(boxstyle='round,pad=0.5',facecolor='#0a0c14',edgecolor=GOLD,linewidth=1.3))

plt.savefig(os.path.join(FIG_DIR,'sfe0513b_manifold.png'),dpi=150,bbox_inches='tight',facecolor=BG)
plt.show(); print(" done.")

print(f"\n  LINEAGE")
print(f"  05.13   Kalman-based, floor-locked: burst_ratio=0.74 > gate(0.59). 0 events.")
print(f"  05.13b  Null predictor: burst={len(res['events_burst'])} bg={len(res['events_bg'])} rec={len(res['events_rec'])}")
print("="*70)
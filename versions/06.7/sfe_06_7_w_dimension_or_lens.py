# -*- coding: utf-8 -*-
"""SFE_06_7_W_Dimension_or_Lens.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1OtcBBx1jYsqJOl9MKZGtdRfmiulRHMwh

# SFE-06.7 — Eigenstructure of the OU Field: Is W a Dimension or a Lens?

**Two independent questions. No new discovery needed. Measurement and clarification.**

**Part A — Δk Precision Calibration**  
SFE-06.6 measured k_ρ≈0.01, k_geom≈0.05, Δk≈0.04 at 0.01 resolution.  
Part A re-measures at 0.001 resolution (31 k values) to confirm or refute.  
Output: one number — Δk precise.

**Part B — W Dependence of e2/e3**  
SFE-06.6 confirmed δ-invariance: peak e2/e3=3.41 identical across δ∈{0,2,5}.  
The remaining free parameters are k and W.  
Part B runs the full micro-sweep at W∈{20, 40, 80}.  
If curves overlap → W is a lens (f(k) only).  
If curves separate → W is a dimension (f(k,W) needed).

**No interactive views. Two static plots saved to file. Run top to bottom.**
"""

# @title ⚠️ Optional: Install dependencies to export images.
INSTALL_PATCH = False  #@param {type:"boolean"}

if INSTALL_PATCH:
    import sys, os, subprocess
    import plotly.io as pio
    import shutil

    # Downgrade Kaleido to 0.2.1 to match Plotly 5.13.1
    subprocess.run([sys.executable, "-m", "pip", "install", "-q", "kaleido==0.2.1", "scikit-learn"], check=True)

    # Make sure Chromium & OS dependencies are installed
    subprocess.run(["apt-get", "-qq", "update"])
    subprocess.run([
        "apt-get", "-qq", "install", "-y", "chromium-browser",
        "libnss3", "libatk-bridge2.0-0", "libcups2", "libxcomposite1", "libxdamage1",
        "libxfixes3", "libxrandr2", "libgbm1", "libxkbcommon0", "libpango-1.0-0",
        "libcairo2", "libasound2"
    ])

    # Add Chromium to PATH for Kaleido
    os.environ["PATH"] += ":/usr/bin/chromium-browser"

    # Check Kaleido availability
    if pio.kaleido.scope is not None:
        print("✅ Patch applied: Plotly 5.13.1 + Kaleido 0.2.1. Restart runtime now.")
    else:
        print("⚠️ Patch applied, but Kaleido not detected. Restart runtime and try again.")
else:
    print(" ")  # Silent if skipped

#@title Imports
import plotly.graph_objects as go
from plotly.subplots import make_subplots
import numpy as np
from sklearn.decomposition import PCA
from sklearn.preprocessing import StandardScaler
import warnings; warnings.filterwarnings('ignore')
print("Imports OK.")

"""## Simulation engine

Single `run_k()` handles both parts via `W` and `return_2d` parameters.  
Physics identical to SFE-06.5/06.6.
"""

#@title Shared simulation engine for both parts

def run_k(k_val, N_cycles=5000, seed=42, observer_offset=2.0, W=40,
          return_2d=False):
    """
    Fixed-k simulation.
    return_2d=False: returns (N, 3) array (xa_meas, xb_meas, corr)
    return_2d=True:  returns (N, 2) array (xa_meas, xb_meas) — for Δk calibration
    """
    kBT=1.0; gamma=1.0; dt=0.01; tau_meas=10
    sigma_m=0.40
    field_volatility = np.sqrt(2*kBT*tau_meas*dt)
    x0=0.0

    rng_a = np.random.default_rng(seed)
    rng_b = np.random.default_rng(seed + 1000)

    xa = 0.0
    xb = float(observer_offset)
    r_a_hist=[]; r_b_hist=[]
    hull_pts=[]; corr_current=0.0

    for cycle in range(N_cycles):
        for _ in range(tau_meas):
            diff = np.sqrt(2*kBT*dt/gamma)
            xa += -k_val*(xa-x0)*dt/gamma + diff*rng_a.standard_normal()
            xb += -k_val*(xb-x0)*dt/gamma + diff*rng_b.standard_normal()

        xa_meas = xa + sigma_m*rng_a.standard_normal()
        xb_meas = xb + sigma_m*rng_b.standard_normal()

        if not return_2d:
            r_a_hist.append(abs(xa_meas)/field_volatility)
            r_b_hist.append(abs(xb_meas)/field_volatility)
            if len(r_a_hist) >= W:
                cc = np.corrcoef(r_a_hist[-W:], r_b_hist[-W:])[0,1]
                corr_current = float(cc) if not np.isnan(cc) else 0.0
            hull_pts.append((float(xa_meas), float(xb_meas), float(corr_current)))
        else:
            hull_pts.append((float(xa_meas), float(xb_meas)))

    return np.array(hull_pts)


print("Simulation engine loaded.")
print("  run_k(k, N_cycles, seed, observer_offset, W, return_2d)")

"""## Part A — Run

31 k values from 0.000 to 0.030, step 0.001. 5000 cycles each.  
Runs both 3D (for |wρ|) and 2D (for e1_2d). ~8-12 minutes.
"""

#@title Part A — Δk Precision Calibration
# k ∈ [0.000, 0.030], step 0.001 (31 values)
# Measures: k_ρ (|wρ| > 0.90) and k_geom (e1_2d > 0.70)
# Reports: Δk = k_geom - k_ρ

k_fine = np.round(np.arange(0.000, 0.031, 0.001), 3).tolist()
N_fine = 5000; burn_fine = 500

print(f"Part A: {len(k_fine)} k values from {k_fine[0]} to {k_fine[-1]}")
print()

clouds_3d_fine = {}
clouds_2d_fine = {}

for k in k_fine:
    print(f"  k={k:.3f}", end=" ", flush=True)
    raw3 = run_k(k, N_fine, seed=42, observer_offset=2.0, W=40, return_2d=False)
    raw2 = run_k(k, N_fine, seed=42, observer_offset=2.0, W=40, return_2d=True)
    clouds_3d_fine[k] = raw3[burn_fine:]
    clouds_2d_fine[k] = raw2[burn_fine:]
    print("✓")

print("\nPart A runs complete.")

"""## Part A — PCA

Detects k_ρ and k_geom, computes Δk.
"""

#@title Part A — PCA and threshold detection

scaler_3f = StandardScaler()
scaler_3f.fit(clouds_3d_fine[0.0])

scaler_2f = StandardScaler()
scaler_2f.fit(clouds_2d_fine[0.0])

pca_3f = {}; pca_2f = {}

for k in k_fine:
    p3 = PCA(n_components=3)
    p3.fit(scaler_3f.transform(clouds_3d_fine[k]))
    pca_3f[k] = {'ev': p3.explained_variance_ratio_, 'c': p3.components_}

    p2 = PCA(n_components=2)
    p2.fit(scaler_2f.transform(clouds_2d_fine[k]))
    pca_2f[k] = {'ev': p2.explained_variance_ratio_}

# Extract curves
wρ_fine   = [abs(pca_3f[k]['c'][0][2]) for k in k_fine]
e1_2d_fine = [pca_2f[k]['ev'][0]        for k in k_fine]

# Threshold detection
k_rho  = next((k for k in k_fine if abs(pca_3f[k]['c'][0][2]) > 0.90), None)
k_geom = next((k for k in k_fine if pca_2f[k]['ev'][0]         > 0.70), None)

dk_precise = round(k_geom - k_rho, 3) if (k_rho and k_geom) else None

print("=" * 60)
print("Part A — Δk Precision Calibration")
print("=" * 60)
print(f"  k_ρ    (|wρ| > 0.90):   {k_rho}")
print(f"  k_geom (e1_2d > 0.70):  {k_geom}")
print(f"  Δk (precise):           {dk_precise}")

if dk_precise is not None:
    if abs(dk_precise - 0.04) <= 0.005:
        print(f"\n  Verdict: Δk ≈ 0.04 — ordering is ROBUST")
        print(f"  SFE-06.6 result confirmed at 0.001 resolution.")
    elif abs(dk_precise) <= 0.002:
        print(f"\n  Verdict: Δk ≈ 0 — was resolution artifact at 0.01 steps")
        print(f"  ρ and geometric transitions are simultaneous.")
    else:
        print(f"\n  Δk = {dk_precise} — intermediate result")

print("=" * 60)

"""## Part A — Plot

`partA_dk_calibration.png` — |wρ| and e1_2d vs k at 0.001 resolution.  
Δk shown as a labeled bracket between the two threshold crossings.
"""

#@title Part A — Plot: |wρ| and e1_2d at 0.001 resolution

fig_a = go.Figure()

fig_a.add_trace(go.Scatter(
    x=k_fine, y=wρ_fine,
    mode='lines+markers', name='|ρ weight in PC1| (3D)',
    line=dict(color='#f5c842', width=2),
    marker=dict(size=4)
))

fig_a.add_trace(go.Scatter(
    x=k_fine, y=e1_2d_fine,
    mode='lines+markers', name='e1 (2D: xa, xb only)',
    line=dict(color='#3dd6c8', width=2, dash='dash'),
    marker=dict(size=4)
))

# Mark thresholds
for y, label, col in [
    (0.90, '|wρ| = 0.90', '#f5c842'),
    (0.70, 'e1_2d = 0.70', '#3dd6c8'),
]:
    fig_a.add_hline(y=y, line_dash='dot', line_color=col, line_width=1,
                    annotation_text=label, annotation_font=dict(color=col, size=9))

# Bracket for Δk
if k_rho and k_geom:
    y_brack = 0.82
    fig_a.add_shape(type='line',
        x0=k_rho, x1=k_geom, y0=y_brack, y1=y_brack,
        line=dict(color='white', width=2))
    fig_a.add_shape(type='line', x0=k_rho,  x1=k_rho,
        y0=y_brack-0.02, y1=y_brack+0.02, line=dict(color='white', width=2))
    fig_a.add_shape(type='line', x0=k_geom, x1=k_geom,
        y0=y_brack-0.02, y1=y_brack+0.02, line=dict(color='white', width=2))
    fig_a.add_annotation(
        x=(k_rho+k_geom)/2, y=y_brack+0.04,
        text=f'Δk = {dk_precise}', font=dict(color='white', size=11),
        showarrow=False)

fig_a.update_layout(
    title=dict(
        text='SFE-06.7 · Part A — Δk Precision Calibration (step = 0.001)<br>'
             '<sup>|wρ| = ρ dominance · e1_2d = geometric collapse · Δk = gap between them</sup>',
        font=dict(color='white')
    ),
    xaxis=dict(title='k (confinement strength)', gridcolor='#333',
               color='#aaa', dtick=0.005),
    yaxis=dict(title='value', gridcolor='#333', color='#aaa', range=[0, 1.1]),
    paper_bgcolor='#07080f', plot_bgcolor='#0a0a0a',
    font=dict(color='white'),
    legend=dict(bgcolor='#0a0a0a', bordercolor='#333'),
    width=1050, height=550
)

fig_a.show()

try:
    fig_a.write_image("partA_dk_calibration.png", width=1400, height=650, scale=2)
    print("Saved: partA_dk_calibration.png")
except Exception as e:
    print(f"Image save: {e}")

"""## Part B — Run

21 k values × 3 W values = 63 runs. 5000 cycles each. ~15-20 minutes.
"""

#@title Part B — W dependence of e2/e3
# Three window sizes on same micro-sweep k ∈ [0.00, 0.20]

k_values = np.round(np.arange(0.00, 0.21, 0.01), 2).tolist()
W_values = [20, 40, 80]
N_sweep  = 5000; burn_sweep = 500

print(f"Part B: {len(k_values)} k values × {len(W_values)} W values")
print()

clouds_W = {}   # clouds_W[W][k] = array

for W in W_values:
    print(f"  W = {W}")
    clouds_W[W] = {}
    for k in k_values:
        print(f"    k={k:.2f}", end=" ", flush=True)
        raw = run_k(k, N_sweep, seed=42, observer_offset=2.0, W=W, return_2d=False)
        clouds_W[W][k] = raw[burn_sweep:]
        print("✓")

print("\nPart B runs complete.")

"""## Part B — PCA + table

Prints the full e2/e3 ratio table across all k and W values.  
Auto-classifies: **W is a dimension** or **W is a lens**.
"""

#@title Part B — PCA and e2/e3 table

pca_W = {}   # pca_W[W][k] = {ev, components}

for W in W_values:
    scaler = StandardScaler()
    scaler.fit(clouds_W[W][0.0])
    pca_W[W] = {}
    for k in k_values:
        norm = scaler.transform(clouds_W[W][k])
        pca  = PCA(n_components=3)
        pca.fit(norm)
        pca_W[W][k] = {'ev': pca.explained_variance_ratio_,
                       'c':  pca.components_}

# Build ratio table
def ratio(W, k):
    ev = pca_W[W][k]['ev']
    return ev[1] / max(ev[2], 1e-6)

print("=" * 72)
print("SFE-06.7 · Part B — e2/e3 Ratio Table")
print("=" * 72)
print(f"{'k':>6}  {'W=20':>9}  {'W=40':>9}  {'W=80':>9}  verdict")
print("-" * 72)

for k in k_values:
    r20 = ratio(20, k); r40 = ratio(40, k); r80 = ratio(80, k)
    spread = max(r20, r40, r80) - min(r20, r40, r80)
    verdict = 'DIVERGE' if spread > 0.5 else 'OVERLAP'
    print(f"{k:>6.2f}  {r20:>9.3f}  {r40:>9.3f}  {r80:>9.3f}  {verdict}")

print("-" * 72)

# Summary
peaks = {W: max(ratio(W, k) for k in k_values) for W in W_values}
thresh = {W: next((k for k in k_values if ratio(W, k) > 2.0), None)
          for W in W_values}

print("\nSummary table:")
print(f"  {'W':>4}  {'peak e2/e3':>10}  {'k at ratio>2.0':>15}")
print(f"  {'-'*4}  {'-'*10}  {'-'*15}")
for W in W_values:
    print(f"  {W:>4}  {peaks[W]:>10.3f}  {str(thresh[W]):>15}")

# Verdict
peak_vals = list(peaks.values())
spread_peaks = max(peak_vals) - min(peak_vals)
print(f"\nPeak e2/e3 spread across W values: {spread_peaks:.3f}")

if spread_peaks > 0.5:
    print("\n  Verdict: W IS A DIMENSION")
    print("  e2/e3 changes with W — information distributes across the window.")
    print("  The ball lives in W. f(k, W) needed.")
else:
    print("\n  Verdict: W IS A LENS")
    print("  e2/e3 stable across W — the invariant is intrinsic to the OU field.")
    print("  W is how we look, not where the ball lives.")
    print("  f(k) only. Derive from steady-state covariance.")

print("=" * 72)

"""## Part B — Plot

`partB_W_dependence.png` — three e2/e3 curves on same axes.  
Overlapping curves confirm lens. Separated curves confirm dimension.
"""

#@title Part B — Plot: e2/e3 for W=20, W=40, W=80

colors_W = {20: '#3dd6c8', 40: '#ff8c42', 80: '#b87aff'}

ratio_curves = {W: [ratio(W, k) for k in k_values] for W in W_values}

fig_b = go.Figure()

for W in W_values:
    fig_b.add_trace(go.Scatter(
        x=k_values, y=ratio_curves[W],
        mode='lines+markers', name=f'W = {W}',
        line=dict(color=colors_W[W], width=2.5),
        marker=dict(size=7)
    ))

fig_b.add_hline(y=2.0, line_dash='dot', line_color='#ff5f7e', line_width=1.5,
               annotation_text='asymmetry threshold (2.0)',
               annotation_font=dict(color='#ff5f7e', size=10))

fig_b.add_hline(y=1.0, line_dash='dot', line_color='#555', line_width=1,
               annotation_text='symmetric (1.0)',
               annotation_font=dict(color='#aaa', size=9))

# Annotate peak spread
for W in W_values:
    pk = peaks[W]
    pk_k = k_values[np.argmax(ratio_curves[W])]
    fig_b.add_annotation(x=pk_k, y=pk+0.08,
        text=f'W={W}: {pk:.2f}',
        font=dict(color=colors_W[W], size=10), showarrow=False)

fig_b.update_layout(
    title=dict(
        text='SFE-06.7 · Part B — e2/e3 Asymmetry vs Window Size W<br>'
             '<sup>Curves overlap → W is a lens  ·  Curves separate → W is a dimension</sup>',
        font=dict(color='white')
    ),
    xaxis=dict(title='k (confinement strength)', gridcolor='#333',
               color='#aaa', dtick=0.02),
    yaxis=dict(title='e2 / e3 ratio', gridcolor='#333', color='#aaa'),
    paper_bgcolor='#07080f', plot_bgcolor='#0a0a0a',
    font=dict(color='white'),
    legend=dict(bgcolor='#0a0a0a', bordercolor='#333',
                title='Window size W'),
    width=1050, height=550
)

fig_b.show()

try:
    fig_b.write_image("partB_W_dependence.png", width=1400, height=650, scale=2)
    print("Saved: partB_W_dependence.png")
except Exception as e:
    print(f"Image save: {e}")

"""## Summary"""

#@title Final summary

print("=" * 72)
print("SFE-06.7 — Eigenstructure of the OU Field: Is W a Dimension or a Lens?")
print("=" * 72)

print("\nPART A — Δk Precision Calibration (0.001 resolution)")
print(f"  k_ρ    (|wρ| > 0.90) :  {k_rho}")
print(f"  k_geom (e1_2d > 0.70):  {k_geom}")
print(f"  Δk (precise)         :  {dk_precise}")
if dk_precise is not None:
    if abs(dk_precise - 0.04) <= 0.005:
        print("  → Ordering ROBUST. SFE-06.6 Δk confirmed.")
    elif abs(dk_precise) <= 0.002:
        print("  → Was resolution artifact. Transitions simultaneous.")
    else:
        print(f"  → Δk = {dk_precise} (between expected values — intermediate)")

print("\nPART B — W Dependence of e2/e3")
for W in W_values:
    t = thresh[W]
    print(f"  W={W:>2}:  peak e2/e3 = {peaks[W]:.3f}  |  k at ratio>2.0 = {t}")

spread_str = f"{spread_peaks:.3f}"
print(f"\n  Peak spread across W: {spread_str}")

if spread_peaks > 0.5:
    print("\n  W IS A DIMENSION")
    print("  The ball fragments across W.")
    print("  Next step: derive f(k, W) from windowed covariance structure.")
else:
    print("\n  W IS A LENS")
    print("  The ball does not live in W.")
    print("  e2/e3 is intrinsic to the OU field at steady state.")
    print("  Next step: derive f(k) from steady-state covariance alone.")

print("\n" + "=" * 72)
print("LINEAGE")
lineage = [
    ("05.12b",   "What a matched filter cannot see"),
    ("05.13b",   "What a single decoupled observer can see"),
    ("SFE-06",   "What the relationship between observers sees"),
    ("SFE-06.2", "The shape of that relationship"),
    ("SFE-06.3", "Navigation inside the shape"),
    ("SFE-06.4", "Full manifold across field conditions"),
    ("SFE-06.5", "Transition boundary, two-step structure"),
    ("SFE-06.6", "Relational gap confirmed, δ-invariance found"),
    ("SFE-06.7", "Is W a dimension or a lens?"),
]
for v, r in lineage:
    print(f"  {v:10s}  {r}")
print("=" * 72)

"""## Lineage

| Version | Result |
|---------|--------|
| 05.12b  | What a matched filter cannot see |
| 05.13b  | What a single decoupled observer can see |
| SFE-06  | What the relationship between observers sees |
| SFE-06.2 | The shape of that relationship |
| SFE-06.3 | Navigation inside the shape |
| SFE-06.4 | Full manifold across field conditions |
| SFE-06.5 | Transition boundary, two-step structure |
| SFE-06.6 | Relational gap confirmed, δ-invariance found |
| SFE-06.7 | Is W a dimension or a lens? |

---

#
"""
# -*- coding: utf-8 -*-
"""SFE_06_5_TransitionBoundary.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/14JzIHVRMFOqK9kPUDxWgQWhKcA1iWwz1

# SFE-06.5 — Transition Boundary · Micro-Sweep k=0 to k=0.2

SFE-06.4 found a phase transition at k≈0.1. This notebook maps it at high resolution.

**Two questions:**
1. Where exactly is the threshold? (precision: 0.01 in k)
2. Does the transition have internal structure? (single event vs. two-step: VOLUMETRIC→PLANAR→LINEAR)

**21 k values**, 0.00 to 0.20 in steps of 0.01. 5000 cycles each, 500 discarded. ~5–8 minutes total.

**Run cells top to bottom.**
"""

# @title ⚠️ Optional: Install dependencies to export images.
INSTALL_PATCH = False  #@param {type:"boolean"}

if INSTALL_PATCH:
    import sys, os, subprocess
    import plotly.io as pio
    import shutil

    # Downgrade Kaleido to 0.2.1 to match Plotly 5.13.1
    subprocess.run([sys.executable, "-m", "pip", "install", "-q", "kaleido==0.2.1", "scikit-learn"], check=True)

    # Make sure Chromium & OS dependencies are installed
    subprocess.run(["apt-get", "-qq", "update"])
    subprocess.run([
        "apt-get", "-qq", "install", "-y", "chromium-browser",
        "libnss3", "libatk-bridge2.0-0", "libcups2", "libxcomposite1", "libxdamage1",
        "libxfixes3", "libxrandr2", "libgbm1", "libxkbcommon0", "libpango-1.0-0",
        "libcairo2", "libasound2"
    ])

    # Add Chromium to PATH for Kaleido
    os.environ["PATH"] += ":/usr/bin/chromium-browser"

    # Check Kaleido availability
    if pio.kaleido.scope is not None:
        print("✅ Patch applied: Plotly 5.13.1 + Kaleido 0.2.1. Restart runtime now.")
    else:
        print("⚠️ Patch applied, but Kaleido not detected. Restart runtime and try again.")
else:
    print(" ")  # Silent if skipped

# @title Cell 1 — Imports
import plotly.graph_objects as go
import plotly.express as px
from plotly.subplots import make_subplots
import numpy as np
from sklearn.decomposition import PCA
from sklearn.preprocessing import StandardScaler
import pandas as pd
import warnings; warnings.filterwarnings('ignore')
print("Imports OK.")

"""## Cell 2 — Micro-sweep simulation

Same `run_k()` as SFE-06.4. Fixed-k, no phase switching. 5000 cycles per k value for stable PCA at the transition boundary.
"""

# @title Cell 2 — Micro-sweep simulation
# 21 k values from 0.00 to 0.20 in steps of 0.01
# 5000 cycles each, 500 burn-in discarded

def run_k(k_val, N_cycles=5000, seed=42):
    kBT=1.0; gamma=1.0; dt=0.01; tau_meas=10
    sigma_m=0.40
    field_volatility = np.sqrt(2*kBT*tau_meas*dt)
    observer_offset = 2.0
    W = 40; x0 = 0.0

    rng_a = np.random.default_rng(seed)
    rng_b = np.random.default_rng(seed + 1000)

    xa = 0.0
    xb = observer_offset
    r_a_hist = []; r_b_hist = []
    hull_pts  = []; corr_current = 0.0

    for cycle in range(N_cycles):
        for step in range(tau_meas):
            diff = np.sqrt(2 * kBT * dt / gamma)
            xa += -k_val * xa * dt / gamma + diff * rng_a.standard_normal()
            xb += -k_val * xb * dt / gamma + diff * rng_b.standard_normal()

        xa_meas = xa + sigma_m * rng_a.standard_normal()
        xb_meas = xb + sigma_m * rng_b.standard_normal()

        r_a_hist.append(abs(xa_meas) / field_volatility)
        r_b_hist.append(abs(xb_meas) / field_volatility)

        if len(r_a_hist) >= W:
            cc = np.corrcoef(r_a_hist[-W:], r_b_hist[-W:])[0, 1]
            corr_current = float(cc) if not np.isnan(cc) else 0.0

        hull_pts.append((float(xa_meas), float(xb_meas), float(corr_current)))

    return np.array(hull_pts)


# High-resolution sweep through transition zone
k_values = np.round(np.arange(0.00, 0.21, 0.01), 2).tolist()
N_cycles_per_k = 5000
burn_in = 500

print(f"k values ({len(k_values)}): {k_values}")
print(f"Cycles per k: {N_cycles_per_k}  Burn-in: {burn_in}")
print()

clouds = {}
for k in k_values:
    print(f"  Running k={k:.2f}...", end=' ', flush=True)
    clouds[k] = run_k(k, N_cycles=N_cycles_per_k, seed=42)
    clouds[k] = clouds[k][burn_in:]
    print(f"{len(clouds[k])} points kept")

print(f"\nAll k values complete.")

"""## Cell 3 — Normalize + PCA + diagnostics

Prints the full table: eigenvalues, CC weight, e2/e3 ratio, shape.

**e2/e3 ratio > 2.0** flags asymmetric collapse — the fingerprint of a two-step transition.
"""

# @title Cell 3 — Normalize + PCA

scaler = StandardScaler()
scaler.fit(clouds[0.0])

clouds_norm = {k: scaler.transform(clouds[k]) for k in k_values}

pca_results = {}
for k in k_values:
    pca = PCA(n_components=3)
    pca.fit(clouds_norm[k])
    pca_results[k] = {
        'eigenvalues': pca.explained_variance_ratio_,
        'components':  pca.components_,
        'transformed': pca.transform(clouds_norm[k])
    }

# Background (k=0) PCA basis for common projection
pca_bg = PCA(n_components=3)
pca_bg.fit(clouds_norm[0.0])

# ── Classify shapes ───────────────────────────────────────────────────────────
def classify(ev):
    if   ev[0] < 0.50: return 'VOLUMETRIC'
    elif ev[0] < 0.70: return 'PLANAR'
    else:              return 'LINEAR'

shapes = {k: classify(pca_results[k]['eigenvalues']) for k in k_values}

# ── Print diagnostics ─────────────────────────────────────────────────────────
print("=" * 78)
print("SFE-06.5 — Micro-Sweep Transition Boundary")
print("=" * 78)
print(f"\n{'k':>6}  {'e1':>6}  {'e2':>6}  {'e3':>6}  {'cc_w':>6}  {'e2/e3':>7}  shape")
print("-" * 78)

for k in k_values:
    ev = pca_results[k]['eigenvalues']
    c0 = pca_results[k]['components'][0]
    cw = abs(c0[2])
    ratio = ev[1]/ev[2] if ev[2] > 1e-6 else 999.0
    print(f"{k:>6.2f}  {ev[0]:>6.3f}  {ev[1]:>6.3f}  {ev[2]:>6.3f}  "
          f"{cw:>6.3f}  {ratio:>7.2f}  {shapes[k]}")

print("-" * 78)

# Shape transition points
print("\nShape transitions:")
prev = shapes[k_values[0]]
for k in k_values[1:]:
    s = shapes[k]
    if s != prev:
        print(f"  {prev} → {s} at k={k:.2f}")
        prev = s

# e2/e3 asymmetry
print("\ne2/e3 ratio through transition:")
print("(ratio > 2.0 = e2 and e3 separating → possible two-step collapse)")
for k in k_values:
    ev = pca_results[k]['eigenvalues']
    ratio = ev[1]/ev[2] if ev[2] > 1e-6 else 999.0
    flag = "  ← asymmetric" if ratio > 2.0 else ""
    print(f"  k={k:.2f}  e2/e3={ratio:.2f}{flag}")

# Sum check
print("\nEigenvalue sum check (should all be ~1.000):")
bad = [(k, sum(pca_results[k]['eigenvalues'])) for k in k_values
       if abs(sum(pca_results[k]['eigenvalues']) - 1.0) > 0.01]
if bad:
    for k, s in bad: print(f"  WARNING k={k:.2f}  sum={s:.4f}")
else:
    print("  All sums within 0.01 of 1.000 — OK")

print("=" * 78)

"""## Viz 1 — All clouds in raw joint space

Interactive 3D. Saved snapshot looking down the correlation axis.

Watch for the k value where the cloud first clearly changes character — that is the transition point visible geometrically.
"""

# @title Visualization 1 — All clouds in raw joint space (x_a, x_b, corr)

colors = px.colors.sample_colorscale(
    'Plasma', [i / (len(k_values) - 1) for i in range(len(k_values))]
)

rng_viz = np.random.default_rng(0)

fig1 = go.Figure()
for i, k in enumerate(k_values):
    pts = clouds[k]
    idx = rng_viz.choice(len(pts), min(300, len(pts)), replace=False)
    fig1.add_trace(go.Scatter3d(
        x=pts[idx, 0], y=pts[idx, 1], z=pts[idx, 2],
        mode='markers',
        marker=dict(size=2, color=colors[i], opacity=0.5),
        name=f'k={k:.2f}'
    ))

# Diagonal reference
dr = np.linspace(-5, 5, 30)
fig1.add_trace(go.Scatter3d(
    x=dr, y=dr, z=np.zeros(30),
    mode='lines',
    line=dict(color='white', width=2, dash='dash'),
    name='x_a=x_b diagonal',
    showlegend=True
))

fig1.update_layout(
    title=dict(
        text='SFE-06.5 · Viz 1 — Micro-Sweep Joint Observer Space<br>'
             '<sup>blue=k=0 (free diffusion) → yellow=k=0.20 (confined)</sup>',
        font=dict(color='white')
    ),
    scene=dict(
        xaxis_title='x_a measurement',
        yaxis_title='x_b measurement',
        zaxis_title='correlation',
        bgcolor='black',
        xaxis=dict(backgroundcolor='#0a0a0a', gridcolor='#333', color='#aaa'),
        yaxis=dict(backgroundcolor='#0a0a0a', gridcolor='#333', color='#aaa'),
        zaxis=dict(backgroundcolor='#0a0a0a', gridcolor='#333', color='#aaa'),
    ),
    paper_bgcolor='#07080f',
    font=dict(color='white'),
    legend=dict(bgcolor='#0a0a0a', bordercolor='#333', font=dict(size=8)),
    width=950, height=750
)

fig1.show()

# Save looking down correlation axis
fig1.update_layout(scene_camera=dict(eye=dict(x=0, y=0, z=2.5)))
try:
    fig1.write_image("viz1_top_corr.png", width=1200, height=800, scale=2)
    print("Saved: viz1_top_corr.png")
except Exception as e:
    print(f"Image save: {e}")

"""## Viz 2 — Three eigenvalue curves **(THE main result)**

**Top panel:** e1, e2, e3 and |corr weight| vs k.

**Bottom panel:** e2/e3 ratio — rises above 2.0 if collapse is sequential.

**What you're looking for:**
- e2 and e3 drop **together** → single snap transition
- e2 drops first, e3 drops later → two separate thresholds
- e2/e3 peak above 2.0 at some k → that k is the intermediate state
"""

# @title Visualization 2 — Three eigenvalue curves (THE main result)
# Shows whether e2 and e3 collapse together (single event) or in sequence (two-step)

e1_vals = [pca_results[k]['eigenvalues'][0] for k in k_values]
e2_vals = [pca_results[k]['eigenvalues'][1] for k in k_values]
e3_vals = [pca_results[k]['eigenvalues'][2] for k in k_values]
cw_vals = [abs(pca_results[k]['components'][0][2]) for k in k_values]

fig2 = make_subplots(
    rows=2, cols=1,
    subplot_titles=[
        'Eigenvalue Trajectories Through Transition',
        'e2 / e3 Ratio  (> 2.0 = asymmetric collapse)'
    ],
    vertical_spacing=0.12
)

# ── Top panel: eigenvalues + corr weight ─────────────────────────────────────
for vals, name, col, width, dash in [
    (e1_vals, 'e1 (dominant)', '#ff8c42', 3, 'solid'),
    (e2_vals, 'e2',            '#3dd6c8', 2, 'solid'),
    (e3_vals, 'e3',            '#b87aff', 2, 'solid'),
    (cw_vals, '|corr weight|', '#f5c842', 2, 'dot'),
]:
    fig2.add_trace(go.Scatter(
        x=k_values, y=vals, mode='lines+markers',
        name=name,
        line=dict(color=col, width=width, dash=dash),
        marker=dict(size=6, color=col)
    ), row=1, col=1)

# Threshold lines
for y, label, col in [
    (0.70, 'LINEAR (e1=0.70)',  '#ff5f7e'),
    (0.50, 'PLANAR  (e1=0.50)', '#f5c842'),
    (0.333,'uniform  (0.333)',  '#555'),
]:
    fig2.add_hline(y=y, row=1, col=1,
                   line_dash='dot', line_color=col, line_width=1,
                   annotation_text=label,
                   annotation_font=dict(color=col, size=10))

# ── Bottom panel: e2/e3 ratio ─────────────────────────────────────────────────
ratio_vals = [pca_results[k]['eigenvalues'][1] /
              max(pca_results[k]['eigenvalues'][2], 1e-6)
              for k in k_values]

fig2.add_trace(go.Scatter(
    x=k_values, y=ratio_vals, mode='lines+markers',
    name='e2/e3 ratio',
    line=dict(color='white', width=2),
    marker=dict(size=6, color='white'),
    showlegend=True
), row=2, col=1)

fig2.add_hline(y=2.0, row=2, col=1,
               line_dash='dot', line_color='#ff5f7e', line_width=1,
               annotation_text='asymmetry threshold (2.0)',
               annotation_font=dict(color='#ff5f7e', size=10))

fig2.update_layout(
    title=dict(
        text='SFE-06.5 · Viz 2 — Three Eigenvalues Through Transition<br>'
             '<sup>Single event = e2 and e3 drop together  ·  Two-step = sequential drops</sup>',
        font=dict(color='white')
    ),
    paper_bgcolor='#07080f',
    plot_bgcolor='#0a0a0a',
    font=dict(color='white'),
    legend=dict(bgcolor='#0a0a0a', bordercolor='#333'),
    width=1100, height=750
)
fig2.update_xaxes(title_text='k (confinement strength)',
                  gridcolor='#333', color='#aaa', dtick=0.02)
fig2.update_yaxes(gridcolor='#333', color='#aaa')
fig2.update_yaxes(range=[0, 1.1], row=1, col=1)

fig2.show()

try:
    fig2.write_image("viz2_eigenvalue_transition.png", width=1400, height=850, scale=2)
    print("Saved: viz2_eigenvalue_transition.png  ← THE main result")
except Exception as e:
    print(f"Image save: {e}")

# ── Interpretation ────────────────────────────────────────────────────────────
max_ratio_k = k_values[np.argmax(ratio_vals)]
max_ratio_v = max(ratio_vals)
print(f"\nPeak e2/e3 asymmetry: {max_ratio_v:.2f} at k={max_ratio_k:.2f}")
if max_ratio_v > 2.0:
    print("  → TWO-STEP transition: e2 and e3 collapse at different thresholds")
else:
    print("  → SINGLE-EVENT transition: e2 and e3 collapse simultaneously")

"""## Viz 3 — All k values in background PCA basis

Projects every cloud into the k=0 coordinate system.
Orbit to the side view (PC2 axis) to see compression along PC1.

Saved snapshot: `viz3_side_PC2.png`
"""

# @title Visualization 3 — PCA basis view (interactive + snapshot)

fig3 = go.Figure()
rng_v3 = np.random.default_rng(1)

for i, k in enumerate(k_values):
    projected = pca_bg.transform(clouds_norm[k])
    idx = rng_v3.choice(len(projected), min(300, len(projected)), replace=False)
    fig3.add_trace(go.Scatter3d(
        x=projected[idx, 0],
        y=projected[idx, 1],
        z=projected[idx, 2],
        mode='markers',
        marker=dict(size=2, color=colors[i], opacity=0.5),
        name=f'k={k:.2f}'
    ))

fig3.update_layout(
    title=dict(
        text='SFE-06.5 · Viz 3 — Micro-Sweep in Background PCA Basis<br>'
             '<sup>Orbit to PC2 view (x=0, y=2.5, z=0) — watch sphere compress along PC1</sup>',
        font=dict(color='white')
    ),
    scene=dict(
        xaxis_title='PC1',
        yaxis_title='PC2',
        zaxis_title='PC3',
        bgcolor='black',
        xaxis=dict(backgroundcolor='#0a0a0a', gridcolor='#333', color='#aaa'),
        yaxis=dict(backgroundcolor='#0a0a0a', gridcolor='#333', color='#aaa'),
        zaxis=dict(backgroundcolor='#0a0a0a', gridcolor='#333', color='#aaa'),
    ),
    paper_bgcolor='#07080f',
    font=dict(color='white'),
    legend=dict(bgcolor='#0a0a0a', bordercolor='#333', font=dict(size=8)),
    width=950, height=750
)

fig3.show()

# Save from the side along PC2 (reveals compression along PC1)
fig3.update_layout(scene_camera=dict(eye=dict(x=0, y=2.5, z=0)))
try:
    fig3.write_image("viz3_side_PC2.png", width=1200, height=800, scale=2)
    print("Saved: viz3_side_PC2.png")
except Exception as e:
    print(f"Image save: {e}")

"""## Viz 4 — Heatmaps

**Left:** Eigenvalue matrix. Each row is one k value. Read top→bottom as k increases. The transition row is visible as a color step in e1.

**Right:** PC1 component weight matrix. Watch the corr column (`|cc_w|`) brighten as k increases — confinement is progressively captured by the correlation dimension.
"""

# @title Visualization 4 — Transition heatmap (2D summary)
# Shows all three eigenvalues as a color grid across k × component

import plotly.graph_objects as go

ev_matrix = np.array([
    [pca_results[k]['eigenvalues'][j] for j in range(3)]
    for k in k_values
])   # shape (21, 3)

cw_matrix = np.array([
    [abs(pca_results[k]['components'][i][j]) for j in range(3)]
    for k in k_values
    for i in range(3)
]).reshape(len(k_values), 3, 3)   # [k, PC, dim]

fig4 = make_subplots(
    rows=1, cols=2,
    subplot_titles=[
        'Eigenvalue matrix  (row=k, col=PC)',
        'PC1 component weights  (col=x_a / x_b / corr)'
    ]
)

# Left: eigenvalue heatmap
fig4.add_trace(go.Heatmap(
    z=ev_matrix,
    x=['e1', 'e2', 'e3'],
    y=[f'{k:.2f}' for k in k_values],
    colorscale='Plasma',
    zmin=0, zmax=1,
    colorbar=dict(x=0.45, title='variance ratio',
                  titlefont=dict(color='white'), tickfont=dict(color='white')),
    text=np.round(ev_matrix, 3),
    texttemplate='%{text}',
    textfont=dict(size=8, color='white')
), row=1, col=1)

# Right: PC1 component weight heatmap
pc1_weights = np.array([
    [abs(pca_results[k]['components'][0][j]) for j in range(3)]
    for k in k_values
])   # shape (21, 3)

fig4.add_trace(go.Heatmap(
    z=pc1_weights,
    x=['|xa_w|', '|xb_w|', '|cc_w|'],
    y=[f'{k:.2f}' for k in k_values],
    colorscale='Inferno',
    zmin=0, zmax=1,
    colorbar=dict(x=1.01, title='|weight|',
                  titlefont=dict(color='white'), tickfont=dict(color='white')),
    text=np.round(pc1_weights, 3),
    texttemplate='%{text}',
    textfont=dict(size=8, color='white')
), row=1, col=2)

fig4.update_layout(
    title=dict(
        text='SFE-06.5 · Viz 4 — Eigenvalue & Component Weight Heatmaps<br>'
             '<sup>Read top→bottom as k increases. Transition row shows where geometry snaps.</sup>',
        font=dict(color='white')
    ),
    paper_bgcolor='#07080f',
    font=dict(color='white'),
    width=1100, height=800
)
fig4.update_xaxes(color='#aaa')
fig4.update_yaxes(color='#aaa', title_text='k value')

fig4.show()

try:
    fig4.write_image("viz4_heatmaps.png", width=1400, height=900, scale=2)
    print("Saved: viz4_heatmaps.png")
except Exception as e:
    print(f"Image save: {e}")

"""## Summary"""

# @title Final summary + transition characterization

print("=" * 78)
print("SFE-06.5 — Transition Boundary Summary")
print("=" * 78)

e1_vals = [pca_results[k]['eigenvalues'][0] for k in k_values]
e2_vals = [pca_results[k]['eigenvalues'][1] for k in k_values]
e3_vals = [pca_results[k]['eigenvalues'][2] for k in k_values]
cw_vals = [abs(pca_results[k]['components'][0][2]) for k in k_values]

# Transition point precision
planar_k = linear_k = corrdom_k = None
for k in k_values:
    ev = pca_results[k]['eigenvalues']
    if planar_k  is None and ev[0] > 0.50: planar_k  = k
    if linear_k  is None and ev[0] > 0.70: linear_k  = k
    if corrdom_k is None and abs(pca_results[k]['components'][0][2]) > 0.90:
        corrdom_k = k

print(f"\nTransition precision (0.01 resolution):")
print(f"  VOLUMETRIC → PLANAR:  k = {planar_k if planar_k else 'not reached'}")
print(f"  PLANAR → LINEAR:      k = {linear_k if linear_k else 'not reached'}")
print(f"  Corr dominates (>0.9): k = {corrdom_k if corrdom_k else 'not reached'}")

# e2/e3 ratio peak
ratio_vals = [e2_vals[i] / max(e3_vals[i], 1e-6) for i in range(len(k_values))]
peak_i = np.argmax(ratio_vals)
print(f"\ne2/e3 peak: {ratio_vals[peak_i]:.2f} at k={k_values[peak_i]:.2f}")

if ratio_vals[peak_i] > 2.0:
    print("  Interpretation: TWO-STEP transition")
    print("  Volumetric→Planar and Planar→Linear are distinct events")
else:
    print("  Interpretation: SINGLE-EVENT transition")
    print("  All three dimensions collapse simultaneously")

# Width of transition zone
in_transition = [k for k in k_values
                 if 0.5 < pca_results[k]['eigenvalues'][0] < 0.7]
if in_transition:
    print(f"\nTransition zone (PLANAR region): {in_transition[0]:.2f} ≤ k ≤ {in_transition[-1]:.2f}")
    print(f"  Width: Δk = {in_transition[-1]-in_transition[0]:.2f}")
else:
    print("\nTransition zone: width < 0.01 (snap transition)")

# Monotonicity
e1_mono = all(e1_vals[i] <= e1_vals[i+1] for i in range(len(e1_vals)-1))
cw_mono = all(cw_vals[i] <= cw_vals[i+1] for i in range(len(cw_vals)-1))
print(f"\ne1 monotone:   {'YES' if e1_mono else 'NO — non-monotone region present'}")
print(f"cc_w monotone: {'YES' if cw_mono else 'NO — check for noise at boundary'}")

print("\n" + "=" * 78)
print("LINEAGE")
print("  05.12b   Showed what a matched filter cannot see")
print("  05.13b   Showed what a single decoupled observer can see")
print("  SFE-06   Showed what the relationship between observers can see")
print("  SFE-06.2 Showed the shape of that relationship")
print("  SFE-06.3 Navigated inside the shape")
print("  SFE-06.4 Mapped the full manifold across all field conditions")
print("  SFE-06.5 Maps the transition boundary itself")
print("=" * 78)

"""## Lineage

| Version | Result |
|---------|--------|
| 05.12b  | Showed what a matched filter cannot see |
| 05.13b  | Showed what a single decoupled observer can see |
| SFE-06  | Showed what the relationship between observers can see |
| SFE-06.2 | Showed the shape of that relationship |
| SFE-06.3 | Navigated inside the shape |
| SFE-06.4 | Mapped the full manifold across all field conditions |
| SFE-06.5 | Maps the transition boundary itself |

---
#
"""
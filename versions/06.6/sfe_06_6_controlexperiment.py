# -*- coding: utf-8 -*-
"""SFE_06_6_ControlExperiment.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1p26aHxfcQoFqggvHm7pHYkeIgrhVZINZ

# SFE-06.6 — Control Experiment: Does the Relational Gap Survive Without ρ?

**The question:** Is the early transition detected in SFE-06.5 (k≈0.01) driven by the correlation channel ρ, or would the same transition appear in the 2D state space `(xa, xb)` alone?

**Three possible outcomes:**
- **A** — 2D and 3D transition at same k → ρ is spatially redundant
- **B** — 2D transition is later than 3D → ρ carries early information (relational gap confirmed)
- **C** — No 2D transition in k∈[0,0.20] → ρ is sole regime carrier (strongest confirmation)

**Secondary question:** Does the e2/e3 asymmetry from SFE-06.5 depend on the observer offset δ? (field property vs. architectural artifact)

**Run cells top to bottom. ~10–15 minutes total.**
"""

# @title ⚠️ Optional: Install dependencies to export images.
INSTALL_PATCH = False  #@param {type:"boolean"}

if INSTALL_PATCH:
    import sys, os, subprocess
    import plotly.io as pio
    import shutil

    # Downgrade Kaleido to 0.2.1 to match Plotly 5.13.1
    subprocess.run([sys.executable, "-m", "pip", "install", "-q", "kaleido==0.2.1", "scikit-learn"], check=True)

    # Make sure Chromium & OS dependencies are installed
    subprocess.run(["apt-get", "-qq", "update"])
    subprocess.run([
        "apt-get", "-qq", "install", "-y", "chromium-browser",
        "libnss3", "libatk-bridge2.0-0", "libcups2", "libxcomposite1", "libxdamage1",
        "libxfixes3", "libxrandr2", "libgbm1", "libxkbcommon0", "libpango-1.0-0",
        "libcairo2", "libasound2"
    ])

    # Add Chromium to PATH for Kaleido
    os.environ["PATH"] += ":/usr/bin/chromium-browser"

    # Check Kaleido availability
    if pio.kaleido.scope is not None:
        print("✅ Patch applied: Plotly 5.13.1 + Kaleido 0.2.1. Restart runtime now.")
    else:
        print("⚠️ Patch applied, but Kaleido not detected. Restart runtime and try again.")
else:
    print(" ")  # Silent if skipped

# @title Cell 1 — Imports
import plotly.graph_objects as go
import plotly.express as px
from plotly.subplots import make_subplots
import numpy as np
from sklearn.decomposition import PCA
from sklearn.preprocessing import StandardScaler
import pandas as pd
import warnings; warnings.filterwarnings('ignore')
print("Imports OK.")

"""## Cell 2 — Simulation engine

`run_k_3d`: state `(xa_meas, xb_meas, corr_ab)` — same as SFE-06.5  
`run_k_2d`: state `(xa_meas, xb_meas)` only — ρ channel removed  

Both use identical seeds and physics. The only difference is whether the correlation channel is included.
"""

# @title Cell 2 — Simulation engine
# run_k_3d: returns (N, 3) array of (xa_meas, xb_meas, corr)
# run_k_2d: returns (N, 2) array of (xa_meas, xb_meas) — no correlation channel

def run_k_3d(k_val, N_cycles=5000, seed=42, observer_offset=2.0):
    """3D state space: (xa_meas, xb_meas, corr_ab).  Same as SFE-06.5."""
    kBT=1.0; gamma=1.0; dt=0.01; tau_meas=10
    sigma_m=0.40
    field_volatility = np.sqrt(2*kBT*tau_meas*dt)
    W=40; x0=0.0

    rng_a = np.random.default_rng(seed)
    rng_b = np.random.default_rng(seed + 1000)

    xa = 0.0
    xb = float(observer_offset)
    r_a_hist=[]; r_b_hist=[]
    hull_pts=[]; corr_current=0.0

    for cycle in range(N_cycles):
        for _ in range(tau_meas):
            diff = np.sqrt(2*kBT*dt/gamma)
            xa += -k_val*(xa-x0)*dt/gamma + diff*rng_a.standard_normal()
            xb += -k_val*(xb-x0)*dt/gamma + diff*rng_b.standard_normal()
        xa_meas = xa + sigma_m*rng_a.standard_normal()
        xb_meas = xb + sigma_m*rng_b.standard_normal()
        r_a_hist.append(abs(xa_meas)/field_volatility)
        r_b_hist.append(abs(xb_meas)/field_volatility)
        if len(r_a_hist) >= W:
            cc = np.corrcoef(r_a_hist[-W:], r_b_hist[-W:])[0,1]
            corr_current = float(cc) if not np.isnan(cc) else 0.0
        hull_pts.append((float(xa_meas), float(xb_meas), float(corr_current)))

    return np.array(hull_pts)


def run_k_2d(k_val, N_cycles=5000, seed=42, observer_offset=2.0):
    """2D state space: (xa_meas, xb_meas) only — no correlation channel."""
    kBT=1.0; gamma=1.0; dt=0.01; tau_meas=10
    sigma_m=0.40; x0=0.0

    rng_a = np.random.default_rng(seed)
    rng_b = np.random.default_rng(seed + 1000)

    xa = 0.0
    xb = float(observer_offset)
    hull_pts=[]

    for cycle in range(N_cycles):
        for _ in range(tau_meas):
            diff = np.sqrt(2*kBT*dt/gamma)
            xa += -k_val*(xa-x0)*dt/gamma + diff*rng_a.standard_normal()
            xb += -k_val*(xb-x0)*dt/gamma + diff*rng_b.standard_normal()
        xa_meas = xa + sigma_m*rng_a.standard_normal()
        xb_meas = xb + sigma_m*rng_b.standard_normal()
        hull_pts.append((float(xa_meas), float(xb_meas)))

    return np.array(hull_pts)


k_values = np.round(np.arange(0.00, 0.21, 0.01), 2).tolist()
N_cycles_per_k = 5000
burn_in = 500

print(f"k values ({len(k_values)}): {k_values}")
print(f"Cycles: {N_cycles_per_k}  Burn-in: {burn_in}")

"""## Cell 3 — Part 1: Run 2D and 3D sweeps

Runs both `run_k_3d` and `run_k_2d` for all 21 k values at δ=2.0. ~5–8 minutes.
"""

# @title Cell 3 — Part 1: Run 2D and 3D sweeps at δ=2.0

clouds_3d = {}
clouds_2d = {}

print("Part 1 — δ=2.0 (standard offset)")
for k in k_values:
    print(f"  k={k:.2f}", end=' ', flush=True)
    raw3 = run_k_3d(k, N_cycles_per_k, seed=42, observer_offset=2.0)
    raw2 = run_k_2d(k, N_cycles_per_k, seed=42, observer_offset=2.0)
    clouds_3d[k] = raw3[burn_in:]
    clouds_2d[k] = raw2[burn_in:]
    print("✓")

print("\nAll runs complete.")

"""## Cell 4 — PCA comparison (Part 1)

Prints the comparison table and auto-detects outcome A, B, or C.

The key number is **Δk**: how many k-steps earlier does the 3D state space detect the transition compared to 2D.
"""

# @title Cell 4 — PCA on 3D and 2D clouds

# ── 3D PCA ────────────────────────────────────────────────────────────────────
scaler_3d = StandardScaler()
scaler_3d.fit(clouds_3d[0.0])
cn_3d = {k: scaler_3d.transform(clouds_3d[k]) for k in k_values}

pca_3d = {}
for k in k_values:
    pca = PCA(n_components=3)
    pca.fit(cn_3d[k])
    pca_3d[k] = {'eigenvalues': pca.explained_variance_ratio_,
                 'components': pca.components_}

# ── 2D PCA ────────────────────────────────────────────────────────────────────
scaler_2d = StandardScaler()
scaler_2d.fit(clouds_2d[0.0])
cn_2d = {k: scaler_2d.transform(clouds_2d[k]) for k in k_values}

pca_2d = {}
for k in k_values:
    pca = PCA(n_components=2)
    pca.fit(cn_2d[k])
    pca_2d[k] = {'eigenvalues': pca.explained_variance_ratio_,
                 'components': pca.components_}

# ── Summary table ─────────────────────────────────────────────────────────────
def classify3(ev):
    if   ev[0] < 0.50: return 'VOLUMETRIC'
    elif ev[0] < 0.70: return 'PLANAR'
    else:              return 'LINEAR'

def classify2(ev):
    """For 2D PCA, LINEAR means e1 > 0.70 (dominant axis)."""
    return 'DOMINANT' if ev[0] > 0.70 else 'SPREAD'

print("=" * 80)
print("SFE-06.6 Part 1 — 3D vs 2D Comparison (δ=2.0)")
print("=" * 80)
print(f"\n{'k':>6}  {'e1_3d':>7}  {'e1_2d':>7}  {'wρ_3d':>7}  {'shape_3d':>11}  {'shape_2d':>10}")
print("-" * 80)

for k in k_values:
    ev3 = pca_3d[k]['eigenvalues']
    ev2 = pca_2d[k]['eigenvalues']
    c0  = pca_3d[k]['components'][0]
    wρ  = abs(c0[2])
    s3  = classify3(ev3)
    s2  = classify2(ev2)
    flag = '  ←' if s3 != classify3(pca_3d[k_values[max(0,k_values.index(k)-1)]]['eigenvalues']) and k > 0 else ''
    print(f"{k:>6.2f}  {ev3[0]:>7.3f}  {ev2[0]:>7.3f}  {wρ:>7.3f}  {s3:>11}  {s2:>10}{flag}")

print("-" * 80)

# Find transition thresholds
thresh_3d = next((k for k in k_values if pca_3d[k]['eigenvalues'][0] > 0.70), None)
thresh_2d = next((k for k in k_values if pca_2d[k]['eigenvalues'][0] > 0.70), None)
wρ_thresh = next((k for k in k_values if abs(pca_3d[k]['components'][0][2]) > 0.90), None)

print(f"\nTransition thresholds (e1 > 0.70):")
print(f"  3D (with ρ):   k = {thresh_3d}")
print(f"  2D (no ρ):     k = {thresh_2d}")
print(f"  ρ dominant:    k = {wρ_thresh}  (|wρ| > 0.90)")

if thresh_3d is not None and thresh_2d is not None:
    dk = round(thresh_2d - thresh_3d, 2)
    print(f"\n  Δk = {dk}")
    if dk > 0:
        print(f"  → OUTCOME B: ρ detects confinement earlier by Δk={dk}")
        print(f"    Relational gap confirmed: ρ carries early field information.")
    elif dk == 0:
        print(f"  → OUTCOME A: 2D and 3D transition at same k.")
        print(f"    ρ is spatially redundant at this resolution.")
    else:
        print(f"  → UNEXPECTED: 3D transitions later than 2D (dk={dk}). Check normalization.")
elif thresh_2d is None:
    print(f"\n  → OUTCOME C: No LINEAR transition in 2D within k=[0,0.20].")
    print(f"    ρ is sole carrier of regime information at low k.")
    print(f"    Strongest confirmation of the relational gap.")

print("=" * 80)

"""## Cell 5 — Part 2: δ sweep

Runs `run_k_3d` at δ ∈ {0.0, 2.0, 5.0} for all 21 k values. ~5–8 minutes.

δ=0.0 is the same-start special case — verifies burn-in removes any trivial shared-start correlation.
"""

# @title Cell 5 — Part 2: δ sweep (3D only, three observer offsets)

deltas = [0.0, 2.0, 5.0]
clouds_delta = {}   # clouds_delta[delta][k] = array

print("Part 2 — δ sweep with ρ")
for delta in deltas:
    print(f"\n  δ = {delta}")
    clouds_delta[delta] = {}
    for k in k_values:
        print(f"    k={k:.2f}", end=' ', flush=True)
        raw = run_k_3d(k, N_cycles_per_k, seed=42, observer_offset=delta)
        clouds_delta[delta][k] = raw[burn_in:]
        print("✓")

print("\nAll δ runs complete.")

"""## Cell 6 — PCA on δ sweep (Part 2)

Prints e2/e3 ratio table for all three δ values and auto-classifies the asymmetry as field property or architectural artifact.
"""

# @title Cell 6 — PCA on δ sweep

pca_delta = {}   # pca_delta[delta][k] = {eigenvalues, components}

for delta in deltas:
    scaler = StandardScaler()
    scaler.fit(clouds_delta[delta][0.0])
    pca_delta[delta] = {}
    for k in k_values:
        norm = scaler.transform(clouds_delta[delta][k])
        pca = PCA(n_components=3)
        pca.fit(norm)
        pca_delta[delta][k] = {'eigenvalues': pca.explained_variance_ratio_,
                               'components': pca.components_}

# e2/e3 ratio curves per delta
print("=" * 70)
print("SFE-06.6 Part 2 — e2/e3 Asymmetry vs Observer Offset δ")
print("=" * 70)
print(f"\n{'k':>6}  {'δ=0.0':>10}  {'δ=2.0':>10}  {'δ=5.0':>10}  verdict")
print("-" * 70)

for k in k_values:
    ratios = []
    for delta in deltas:
        ev = pca_delta[delta][k]['eigenvalues']
        r  = ev[1] / max(ev[2], 1e-6)
        ratios.append(r)
    spread = max(ratios) - min(ratios)
    verdict = 'DIVERGE' if spread > 0.5 else 'OVERLAP'
    print(f"{k:>6.2f}  {ratios[0]:>10.3f}  {ratios[1]:>10.3f}  {ratios[2]:>10.3f}  {verdict}")

print("-" * 70)

# δ=0 check: is ρ trivially high at k=0?
ev0_d0 = pca_delta[0.0][0.0]['eigenvalues']
c0_d0  = pca_delta[0.0][0.0]['components'][0]
print(f"\nδ=0 at k=0 check (burn-in should remove shared-start correlation):")
print(f"  e1={ev0_d0[0]:.3f}  |wρ|={abs(c0_d0[2]):.3f}")
if ev0_d0[0] < 0.5:
    print("  OK — burn-in sufficient. Not spuriously correlated at start.")
else:
    print("  WARNING — δ=0 k=0 shows elevated e1. May need longer burn-in.")

# Verdict on architectural vs field property
max_spreads = [max(pca_delta[d][k]['eigenvalues'][1]/max(pca_delta[d][k]['eigenvalues'][2],1e-6)
                   for k in k_values) for d in deltas]
print(f"\nPeak e2/e3 per δ:  {[f'δ={d}: {v:.2f}' for d, v in zip(deltas, max_spreads)]}")
if max(max_spreads) - min(max_spreads) > 1.0:
    print("  → e2/e3 asymmetry DEPENDS on δ: ARCHITECTURAL property.")
    print("    The asymmetric collapse is a feature of the observer offset,")
    print("    not of the field geometry itself.")
else:
    print("  → e2/e3 asymmetry STABLE across δ: FIELD property.")
    print("    The asymmetric collapse is intrinsic to the OU field structure.")

print("=" * 70)

"""## Viz 1 — 3D vs 2D transition curves

**The core falsification plot.** Orange = 3D (with ρ), teal dashed = 2D (no ρ).

The shaded area between them is the information contributed by ρ alone. If the shaded area has positive width at any k, the relational gap is real.
"""

# @title Visualization 1 — e1_3d vs e1_2d across k (the core comparison)

e1_3d_vals = [pca_3d[k]['eigenvalues'][0] for k in k_values]
e1_2d_vals = [pca_2d[k]['eigenvalues'][0] for k in k_values]
wρ_vals    = [abs(pca_3d[k]['components'][0][2]) for k in k_values]

fig1 = go.Figure()

fig1.add_trace(go.Scatter(
    x=k_values, y=e1_3d_vals,
    mode='lines+markers', name='e1  (3D: xa, xb, ρ)',
    line=dict(color='#ff8c42', width=3),
    marker=dict(size=7)
))

fig1.add_trace(go.Scatter(
    x=k_values, y=e1_2d_vals,
    mode='lines+markers', name='e1  (2D: xa, xb only)',
    line=dict(color='#3dd6c8', width=3, dash='dash'),
    marker=dict(size=7)
))

fig1.add_trace(go.Scatter(
    x=k_values, y=wρ_vals,
    mode='lines+markers', name='|ρ weight in PC1| (3D)',
    line=dict(color='#f5c842', width=2, dash='dot'),
    marker=dict(size=6)
))

# Shade the gap between 3D and 2D curves
fig1.add_trace(go.Scatter(
    x=k_values + k_values[::-1],
    y=e1_3d_vals + e1_2d_vals[::-1],
    fill='toself', fillcolor='rgba(255,95,126,0.12)',
    line=dict(color='rgba(0,0,0,0)'),
    showlegend=True, name='relational gap (3D − 2D)'
))

for y, label, col in [
    (0.70, 'LINEAR (0.70)',  '#ff5f7e'),
    (0.50, 'PLANAR  (0.50)', '#f5c842'),
]:
    fig1.add_hline(y=y, line_dash='dot', line_color=col,
                   annotation_text=label,
                   annotation_font=dict(color=col, size=10))

fig1.update_layout(
    title=dict(
        text='SFE-06.6 · Viz 1 — 3D vs 2D Transition<br>'
             '<sup>Shaded area = information contributed by ρ alone · '
             'Gap shift = Δk (relational advantage)</sup>',
        font=dict(color='white')
    ),
    xaxis=dict(title='k (confinement strength)', gridcolor='#333',
               color='#aaa', dtick=0.02),
    yaxis=dict(title='e1 (dominant eigenvalue)', gridcolor='#333',
               color='#aaa', range=[0, 1.1]),
    paper_bgcolor='#07080f', plot_bgcolor='#0a0a0a',
    font=dict(color='white'),
    legend=dict(bgcolor='#0a0a0a', bordercolor='#333'),
    width=1050, height=580
)

fig1.show()

try:
    fig1.write_image("viz1_3d_vs_2d.png", width=1400, height=700, scale=2)
    print("Saved: viz1_3d_vs_2d.png")
except Exception as e:
    print(f"Image save: {e}")

"""## Viz 2 — e2/e3 asymmetry vs δ

Three curves, one per observer offset. If they overlap → the asymmetric collapse is a field property. If they diverge → it's an artifact of the observer configuration.
"""

# @title Visualization 2 — e2/e3 asymmetry vs δ (three curves on same axes)

fig2 = go.Figure()

colors_delta = {'0.0': '#3dd6c8', '2.0': '#ff8c42', '5.0': '#b87aff'}

for delta in deltas:
    ratio_vals = [pca_delta[delta][k]['eigenvalues'][1] /
                  max(pca_delta[delta][k]['eigenvalues'][2], 1e-6)
                  for k in k_values]
    fig2.add_trace(go.Scatter(
        x=k_values, y=ratio_vals,
        mode='lines+markers', name=f'δ={delta}',
        line=dict(color=colors_delta[str(delta)], width=2),
        marker=dict(size=7)
    ))

fig2.add_hline(y=2.0, line_dash='dot', line_color='#ff5f7e',
               annotation_text='asymmetry threshold (2.0)',
               annotation_font=dict(color='#ff5f7e', size=10))

fig2.add_hline(y=1.0, line_dash='dot', line_color='#555',
               annotation_text='symmetric (1.0)',
               annotation_font=dict(color='#aaa', size=9))

fig2.update_layout(
    title=dict(
        text='SFE-06.6 · Viz 2 — e2/e3 Asymmetry vs Observer Offset δ<br>'
             '<sup>Curves overlap → field property · Curves diverge → architectural artifact</sup>',
        font=dict(color='white')
    ),
    xaxis=dict(title='k (confinement strength)', gridcolor='#333',
               color='#aaa', dtick=0.02),
    yaxis=dict(title='e2/e3 ratio', gridcolor='#333', color='#aaa'),
    paper_bgcolor='#07080f', plot_bgcolor='#0a0a0a',
    font=dict(color='white'),
    legend=dict(bgcolor='#0a0a0a', bordercolor='#333',
                title='Observer offset δ'),
    width=1050, height=550
)

fig2.show()

try:
    fig2.write_image("viz2_delta_sweep.png", width=1400, height=650, scale=2)
    print("Saved: viz2_delta_sweep.png")
except Exception as e:
    print(f"Image save: {e}")

"""## Viz 3 — Full comparison (SFE-06.5 style + 2D overlay)

Reproduces the SFE-06.5 eigenvalue plot with the 2D e1 curve overlaid in white dashed. The gap between orange (3D e1) and white (2D e1) is the ρ contribution at each k value.
"""

# @title Visualization 3 — Full eigenvalue trajectories (SFE-06.5 style) + 2D overlay

e1_3 = [pca_3d[k]['eigenvalues'][0] for k in k_values]
e2_3 = [pca_3d[k]['eigenvalues'][1] for k in k_values]
e3_3 = [pca_3d[k]['eigenvalues'][2] for k in k_values]
e1_2 = [pca_2d[k]['eigenvalues'][0] for k in k_values]
wρ   = [abs(pca_3d[k]['components'][0][2]) for k in k_values]
ratio_3 = [e2_3[i]/max(e3_3[i],1e-6) for i in range(len(k_values))]

fig3 = make_subplots(
    rows=2, cols=1,
    subplot_titles=[
        'Eigenvalue Trajectories: 3D (solid) + 2D e1 (dashed white)',
        'e2/e3 Ratio (3D, δ=2.0)'
    ],
    vertical_spacing=0.12
)

# Top: eigenvalues
for vals, name, col, width, dash in [
    (e1_3, 'e1 3D',         '#ff8c42', 3, 'solid'),
    (e2_3, 'e2 3D',         '#3dd6c8', 2, 'solid'),
    (e3_3, 'e3 3D',         '#b87aff', 2, 'solid'),
    (wρ,   '|ρ weight| 3D', '#f5c842', 2, 'dot'),
    (e1_2, 'e1 2D (no ρ)',  '#ffffff', 2, 'dash'),
]:
    fig3.add_trace(go.Scatter(
        x=k_values, y=vals, mode='lines+markers', name=name,
        line=dict(color=col, width=width, dash=dash),
        marker=dict(size=5, color=col)
    ), row=1, col=1)

for y, label, col in [
    (0.70, 'LINEAR', '#ff5f7e'), (0.50, 'PLANAR', '#f5c842'), (0.333, '1/3', '#444')
]:
    fig3.add_hline(y=y, row=1, col=1, line_dash='dot',
                   line_color=col, line_width=1,
                   annotation_text=label,
                   annotation_font=dict(color=col, size=9))

# Bottom: e2/e3 ratio
fig3.add_trace(go.Scatter(
    x=k_values, y=ratio_3, mode='lines+markers',
    name='e2/e3 (3D)', line=dict(color='white', width=2),
    marker=dict(size=6)
), row=2, col=1)
fig3.add_hline(y=2.0, row=2, col=1, line_dash='dot',
               line_color='#ff5f7e', line_width=1,
               annotation_text='asymmetry=2.0',
               annotation_font=dict(color='#ff5f7e', size=9))

fig3.update_layout(
    title=dict(
        text='SFE-06.6 · Viz 3 — Full Comparison (3D + 2D overlay)<br>'
             '<sup>White dashed = 2D e1. Gap between orange and white = ρ contribution.</sup>',
        font=dict(color='white')
    ),
    paper_bgcolor='#07080f', plot_bgcolor='#0a0a0a',
    font=dict(color='white'),
    legend=dict(bgcolor='#0a0a0a', bordercolor='#333'),
    width=1100, height=780
)
fig3.update_xaxes(title_text='k', gridcolor='#333', color='#aaa', dtick=0.02)
fig3.update_yaxes(gridcolor='#333', color='#aaa')
fig3.update_yaxes(range=[0, 1.1], row=1, col=1)

fig3.show()

try:
    fig3.write_image("viz3_full_comparison.png", width=1400, height=900, scale=2)
    print("Saved: viz3_full_comparison.png  ← full comparison")
except Exception as e:
    print(f"Image save: {e}")

"""## Summary"""

# @title Final summary

print("=" * 78)
print("SFE-06.6 — Control Experiment: Does the Relational Gap Survive Without ρ?")
print("=" * 78)

# ── Part 1 results ────────────────────────────────────────────────────────────
thresh_3d = next((k for k in k_values if pca_3d[k]['eigenvalues'][0] > 0.70), None)
thresh_2d = next((k for k in k_values if pca_2d[k]['eigenvalues'][0] > 0.70), None)
wρ_thresh = next((k for k in k_values
                  if abs(pca_3d[k]['components'][0][2]) > 0.90), None)

print(f"\nPART 1 — 3D vs 2D (δ=2.0)")
print(f"  3D LINEAR threshold (with ρ):  k = {thresh_3d}")
print(f"  2D LINEAR threshold (no ρ):    k = {thresh_2d}")
print(f"  ρ dominant in PC1 (|wρ|>0.9):  k = {wρ_thresh}")

if thresh_3d is not None and thresh_2d is not None:
    dk = round(thresh_2d - thresh_3d, 2)
    print(f"  Δk = {dk:+.2f}")
    if dk > 0:
        print(f"\n  OUTCOME B: ρ detects confinement EARLIER by Δk={dk}")
        print( "  → Relational gap confirmed.")
        print( "  → ρ carries field information not present in (xa,xb) at same k.")
    elif dk == 0:
        print(f"\n  OUTCOME A: Transitions coincide.")
        print( "  → ρ is spatially redundant at this resolution.")
        print( "  → Relational gap is a descriptor artifact, not an independent channel.")
    else:
        print(f"\n  ANOMALY: 3D transitions LATER than 2D (Δk={dk}).")
        print( "  → ρ smoothing may be delaying detection. Review W parameter.")
elif thresh_2d is None:
    print(f"\n  OUTCOME C: 2D shows no LINEAR transition in k∈[0,0.20].")
    print( "  → ρ is sole carrier of regime information at low k.")
    print( "  → Strongest confirmation of the relational gap.")

# ── Part 2 results ────────────────────────────────────────────────────────────
print(f"\nPART 2 — δ sweep (e2/e3 asymmetry vs observer offset)")
peak_ratios = {}
for delta in deltas:
    peak_ratios[delta] = max(
        pca_delta[delta][k]['eigenvalues'][1] /
        max(pca_delta[delta][k]['eigenvalues'][2], 1e-6)
        for k in k_values
    )
    print(f"  δ={delta}:  peak e2/e3 = {peak_ratios[delta]:.2f}")

spread = max(peak_ratios.values()) - min(peak_ratios.values())
if spread > 1.0:
    print(f"\n  Spread = {spread:.2f} → ARCHITECTURAL property.")
    print( "  Asymmetric collapse depends on observer offset.")
    print( "  Remove from field-geometry narrative.")
else:
    print(f"\n  Spread = {spread:.2f} → FIELD property.")
    print( "  Asymmetric collapse is intrinsic to OU structure.")
    print( "  Pursue analytical derivation from OU covariance.")

# δ=0 verification
ev0 = pca_delta[0.0][0.0]['eigenvalues']
print(f"\nδ=0 k=0 burn-in check:  e1={ev0[0]:.3f}")
print(f"  {'OK — burn-in sufficient' if ev0[0] < 0.5 else 'WARNING — may need longer burn-in'}")

print("\n" + "=" * 78)
print("LINEAGE")
for v, r in [
    ("05.12b",  "Showed what a matched filter cannot see"),
    ("05.13b",  "Showed what a single decoupled observer can see"),
    ("SFE-06",  "Showed what the relationship between observers can see"),
    ("SFE-06.2","Showed the shape of that relationship"),
    ("SFE-06.3","Navigated inside the shape"),
    ("SFE-06.4","Mapped the full manifold across all field conditions"),
    ("SFE-06.5","Mapped the transition boundary, found two-step structure"),
    ("SFE-06.6","Tested whether the relational gap survives without ρ"),
]:
    print(f"  {v:10s}  {r}")
print("=" * 78)

"""## Lineage

| Version | Result |
|---------|--------|
| 05.12b  | Showed what a matched filter cannot see |
| 05.13b  | Showed what a single decoupled observer can see |
| SFE-06  | Showed what the relationship between observers can see |
| SFE-06.2 | Showed the shape of that relationship |
| SFE-06.3 | Navigated inside the shape |
| SFE-06.4 | Mapped the full manifold across all field conditions |
| SFE-06.5 | Mapped the transition boundary, found two-step structure |
| SFE-06.6 | Tested whether the relational gap survives without ρ |

---
#
"""
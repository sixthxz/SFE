# -*- coding: utf-8 -*-
"""SFE-06

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1oelCPhbvMeMzQLntSD9yiFxhnrUJ8deA
"""

# @title SFE 06
# -*- coding: utf-8 -*-
"""SFE-06 — Multi-Observer Architecture · Cross-Correlation Detection · Unbounded Domain

Extends SFE-05.13b:
  1. Periodic / extended domain — removes hard-wall compression, recovers 4.4σ separation
  2. Two null predictor observers (A at 0, B at offset=2) — spatially separated, decoupled
  3. Windowed cross-correlation between null ratio streams — detects shared OU geometry
     that neither observer sees alone

Kalman channel retained for agent control only. Observers feed nothing into estimator.
"""

import numpy as np
import matplotlib
import matplotlib.pyplot as plt
from matplotlib.gridspec import GridSpec
from mpl_toolkits.mplot3d.art3d import Poly3DCollection
from matplotlib.lines import Line2D
from scipy.spatial import ConvexHull, QhullError
from scipy.ndimage import uniform_filter1d
import warnings; warnings.filterwarnings('ignore')
np.random.seed(42)
import os; FIG_DIR = '/tmp/sfe06_figs'; os.makedirs(FIG_DIR, exist_ok=True)

print("="*70)
print("SFE-06  —  Multi-Observer · Cross-Correlation · Unbounded Domain")
print("="*70)

# ─── PHYSICS ──────────────────────────────────────────────────────────────────
kBT=1.0; gamma=1.0; D_diff=kBT/gamma
dt=0.01; tau_meas=10

# Extended domain — free diffusion variance no longer wall-compressed
domain        = 'extended'     # 'extended' or 'periodic'
x_min, x_max  = -50.0, 50.0
Nx = 400
x_grid = np.linspace(x_min, x_max, Nx); dx = x_grid[1] - x_grid[0]

sigma_m          = 0.40
field_volatility = np.sqrt(2*D_diff*tau_meas*dt)   # normalisation

# ─── PHASE STRUCTURE ──────────────────────────────────────────────────────────
N_background    = 1000
N_burst         = 200
N_recovery      = 400
N_cycles        = N_background + N_burst + N_recovery   # 1600

k_background    = 0.0
k_burst         = 1.0
observer_offset = 2.0
z_sigma         = 1.5
W               = 40      # window width
N_bl            = 10      # baseline windows

# ─── AGENT PARAMS (carry-forward from 05.13b) ─────────────────────────────────
BUFFER_N=512; anomaly_buf_size=256; gate_multiplier=1.0; gate_window=50
min_core_rate=0.20; coherence_var_th=0.15; alpha_attract=0.15
min_events_before=10; n_candidates=5; rehearsal_on=True
dt_coherent=dt; dt_surprised=dt*0.5
lambda_coup_init=0.30; lambda_min=0.05; lambda_max=0.80
sigma_memory=1.20; x0=0.0; window_scale=1.0
N_steps = N_cycles * tau_meas

# ─── THEORY ───────────────────────────────────────────────────────────────────
# Unbounded diffusion variance grows as 2*D*t — no longer clipped at 8²
# For background: variance after N_background * tau_meas * dt steps ≈ 2*D_diff*(N_background*tau_meas*dt)
t_background = N_background * tau_meas * dt
Var_x_bg_theory    = 2 * D_diff * t_background   # ~200 for default params
Var_x_burst_theory = kBT / k_burst               # 1.0
E_bg    = np.sqrt(2/np.pi) * np.sqrt(Var_x_bg_theory + sigma_m**2) / field_volatility
E_burst = np.sqrt(2/np.pi) * np.sqrt(Var_x_burst_theory + sigma_m**2) / field_volatility
std_bg_win = (np.sqrt(1-2/np.pi) * np.sqrt(Var_x_bg_theory + sigma_m**2)
              / field_volatility / np.sqrt(W))
sep_sigma  = (E_bg - E_burst) / std_bg_win

print(f"\n  sigma_m={sigma_m}  field_vol={field_volatility:.4f}  domain={domain}")
print(f"  Background: {N_background} cyc  Burst: {N_burst} cyc  Recovery: {N_recovery} cyc")
print(f"  Observer A: x=0  Observer B: x={observer_offset}")
print(f"  Theory: bg_ratio~{E_bg:.2f}  burst_ratio~{E_burst:.2f}  sep~{sep_sigma:.1f}σ")
print()

# ─── HELPERS ──────────────────────────────────────────────────────────────────
def _gr(m, s):
    r = np.exp(-0.5*((x_grid-m)/s)**2)
    return r / np.trapezoid(r, x_grid)

def fp_step(rho, F, k=0., x0w=0.):
    Ft = F - k*(x_grid - x0w)
    N_ = len(rho)
    v = Ft / gamma; df = np.zeros(N_+1); ff = np.zeros(N_+1)
    for i in range(1, N_):
        vf = 0.5*(v[i-1]+v[i])
        df[i] = vf*rho[i-1] if vf >= 0 else vf*rho[i]
        ff[i] = D_diff*(rho[i]-rho[i-1])/dx
    rn = np.maximum(rho - (dt/dx)*np.diff(df-ff), 0.)
    nm = np.trapezoid(rn, x_grid)
    return rn/nm if nm > 1e-12 else rn

def fp_flux(rho, F):
    return (F/gamma)*rho - D_diff*np.gradient(rho, x_grid)

def wrap_position(x):
    """Periodic boundary wrap."""
    return ((x - x_min) % (x_max - x_min)) + x_min

def clip_position(x):
    """Extended domain soft-clip (only near hard boundaries)."""
    return float(np.clip(x, x_min + 0.1, x_max - 0.1))

def apply_boundary(x):
    if domain == 'periodic':
        return wrap_position(x)
    else:
        return clip_position(x)

def compute_alignment(xp, rt, rp):
    gt = float(np.interp(xp, x_grid, np.gradient(rt, x_grid)))
    gp = float(np.interp(xp, x_grid, np.gradient(rp, x_grid)))
    if abs(gt) < 1e-10 or abs(gp) < 1e-10: return 0.
    return float(np.clip(gt*gp/(abs(gt)*abs(gp)), -1., 1.))

def convex_hull_3d(pts):
    if len(pts) < 5: return 0., 0., None
    try: h = ConvexHull(pts); return h.volume, h.area, h
    except QhullError: return 0., 0., None

def pca_axes(pts):
    if len(pts) < 4: return np.array([1.,0.,0.]), np.eye(3)
    c = pts - pts.mean(0); cov = np.cov(c.T)
    if cov.ndim < 2: return np.array([1.,0.,0.]), np.eye(3)
    vals, vecs = np.linalg.eigh(cov)
    order = np.argsort(vals)[::-1]
    vals = np.maximum(vals[order], 0.); vecs = vecs[:, order]
    return vals/(vals.sum()+1e-12), vecs.T

def classify_geometry(pca_ratio):
    v0, v1, v2 = pca_ratio
    if   v0 > 0.70: return "LINEAR"
    elif v0 > 0.50: return "PLANAR"
    elif v2 > 0.25: return "VOLUMETRIC"
    else:           return "PLANAR"

# ─── CLASSES ──────────────────────────────────────────────────────────────────
class CircularBuffer:
    def __init__(self, N, cols=3):
        self.N=N; self.cols=cols
        self.buf=np.zeros((N,cols), dtype=np.float32); self.filled=self.writes=0
    def push(self, row):
        self.writes+=1; self.buf=np.roll(self.buf, shift=1, axis=0)
        self.buf[0]=np.array(row, dtype=np.float32); self.filled=min(self.filled+1, self.N)
    def get_numpy(self): return self.buf[:self.filled]
    def normalize(self):
        d = self.get_numpy()
        if len(d) < 4: return d, np.zeros(self.cols), np.ones(self.cols)
        mu=d.mean(0); sig=d.std(0)+1e-8; return (d-mu)/sig, mu, sig

class AdaptiveGate:
    def __init__(self, mult, window, floor):
        self.mult=mult; self.window=window; self.floor=floor; self._h=[]; self.threshold=floor
    def update(self, s):
        self._h.append(s)
        if len(self._h) > self.window: self._h.pop(0)
        if len(self._h) >= 4:
            self.threshold = max(float(np.std(self._h))*self.mult, self.floor)
        return self.threshold
    def core_gate(self, s):    return s <= self.threshold
    def anomaly_gate(self, s): return s  > self.threshold

class KalmanOU:
    def __init__(self, k=0.0):
        self.k=k; self.x_hat=0.0; self.P=2*kBT/gamma*tau_meas*dt
    def predict_n(self, n):
        if self.k == 0.0: self.P += n*2*kBT/gamma*dt
        else:
            a=np.exp(-self.k*dt*n); sou=kBT/self.k
            self.x_hat *= a; self.P=self.P*a**2+sou*(1-a**2)
    def update(self, z):
        K=self.P/(self.P+sigma_m**2)
        inn=z-self.x_hat; self.x_hat+=K*inn; self.P*=(1-K)
        return abs(inn)

class PerceivedField:
    def __init__(self, mx=300): self.s=[]; self.w=[]; self.mx=mx
    def add(self, xp, w=1.0):
        self.s.append(xp); self.w.append(w)
        if len(self.s) > self.mx: self.s.pop(0); self.w.pop(0)
    def get_rho(self):
        if len(self.s) < 2: return _gr(0., 1.)
        rho=np.zeros(Nx); wt=sum(self.w)
        for xp, w in zip(self.s, self.w):
            rho += (w/wt)*np.exp(-0.5*((x_grid-xp)/sigma_memory)**2)
        nm=np.trapezoid(rho, x_grid); return rho/nm if nm > 1e-12 else rho

class CoherenceCentroid:
    def __init__(self): self.centroid=np.zeros(3); self.n=0
    def update(self, pos):
        self.n+=1; self.centroid=((self.n-1)*self.centroid+pos)/self.n
        return self.centroid.copy()
    def attraction_force_x(self, c):
        return alpha_attract*(self.centroid[0]-c) if self.n > 0 else 0.
    @property
    def is_ready(self): return self.n >= min_events_before
    @property
    def position(self): return self.centroid.copy()

class NullPredictorGate:
    """Single-observer null predictor gate (replicates 05.13b)."""
    def __init__(self, z_sig):
        self.z_sig=z_sig
        self._bg_win_ratios=[]; self._all_win_ratios=[]
        self.baseline_mean=None; self.baseline_std=None; self.gate_floor=None
        self.frozen=False
        self.n_crossings=0; self.n_verified=0; self.n_rejected=0
    def push_background(self, r):
        self._bg_win_ratios.append(r); self._all_win_ratios.append(r)
    def freeze(self):
        self.baseline_mean=float(np.mean(self._bg_win_ratios))
        self.baseline_std =float(np.std(self._bg_win_ratios))+1e-8
        self.gate_floor   =self.baseline_mean - self.z_sig*self.baseline_std
        self.frozen=True
        return self.baseline_mean, self.baseline_std, self.gate_floor
    def push_active(self, r): self._all_win_ratios.append(r)
    def check(self, r, rv, core_rate, pts, cycle):
        if not self.frozen: return False, False, float('nan')
        delta=r - self.gate_floor; crossing=(r < self.gate_floor)
        if crossing:
            self.n_crossings += 1
            prev=self._all_win_ratios[-2] if len(self._all_win_ratios)>=2 else r
            verified=(prev < self.gate_floor)
            if verified: self.n_verified+=1
            else: self.n_rejected+=1
            struct_ok=(rv < coherence_var_th) and (core_rate >= min_core_rate)
            if verified and struct_ok and len(pts)>=5:
                return True, True, delta
        return False, False, delta
    @property
    def verif_reject_rate(self): return self.n_rejected/max(self.n_crossings,1)
    @property
    def all_win_ratios(self): return np.array(self._all_win_ratios)

class CrossCorrGate:
    """
    Cross-correlation detector between two null ratio streams.
    Signal = Pearson r at lag 0 over rolling window of width W.
    Baseline from first N_bl windows. Gate fires when corr > mean + z_sigma*std.
    """
    def __init__(self, z_sig, window=W):
        self.z_sig=z_sig; self.W=window
        self._bg_corrs=[]; self._all_corrs=[]
        self.baseline_mean=None; self.baseline_std=None; self.gate_ceil=None
        self.frozen=False
        self.n_events=0
    def _corr(self, ra, rb):
        if len(ra) < 4: return 0.
        c=np.corrcoef(ra, rb)
        return float(c[0,1]) if np.isfinite(c[0,1]) else 0.
    def push_background(self, ra, rb):
        c=self._corr(ra, rb)
        self._bg_corrs.append(c); self._all_corrs.append(c)
        return c
    def freeze(self):
        self.baseline_mean=float(np.mean(self._bg_corrs))
        self.baseline_std =float(np.std(self._bg_corrs))+1e-8
        self.gate_ceil    =self.baseline_mean + self.z_sig*self.baseline_std
        self.frozen=True
        return self.baseline_mean, self.baseline_std, self.gate_ceil
    def push_active(self, ra, rb):
        c=self._corr(ra, rb); self._all_corrs.append(c); return c
    def check(self, c):
        if not self.frozen: return False
        if c > self.gate_ceil: self.n_events+=1; return True
        return False
    @property
    def all_corrs(self): return np.array(self._all_corrs)

# ─── MAIN RUN ─────────────────────────────────────────────────────────────────
def run():
    rng=np.random.default_rng(42)

    # ── Agent (Kalman + FP, carries forward from 05.13b) ──
    kf=KalmanOU(k=k_background)
    pf=PerceivedField()
    cb=CircularBuffer(BUFFER_N); ab=CircularBuffer(anomaly_buf_size)
    wg=AdaptiveGate(gate_multiplier, gate_window, floor=field_volatility)
    cen=CoherenceCentroid()
    rho=_gr(0., 2.); F0=np.zeros(Nx)
    x=0.; pf.add(x)   # agent position
    lam=lambda_coup_init; cur_sr=2.; campo_last=0.

    # ── Observer A (null predictor, no coupling, no Kalman, starts at x=0) ──
    xa = 0.0
    gate_a=NullPredictorGate(z_sigma)

    # ── Observer B (null predictor, offset initialisation) ──
    xb = observer_offset
    gate_b=NullPredictorGate(z_sigma)   # for completeness, same gate logic

    # ── Cross-correlation gate ──
    cc_gate=CrossCorrGate(z_sigma, W)

    # ── Logs ──
    null_ratio_a_log=[]; null_ratio_b_log=[]
    corr_log=[]; corr_cycle_log=[]
    win_cycle_log=[]; phase_log=[]
    kalman_ratio_log=[]
    events_single=[]; event_cycles_single=[]
    events_cc=[]; event_cycles_cc=[]
    vw=[]; null_sw_a=[]; null_sw_b=[]; kalman_sw=[]
    total=0; cw=0; aw=0; cycle=0
    baseline_frozen=False

    # For variance diagnostics
    xa_bg_hist=[]; xb_bg_hist=[]

    for i in range(N_steps):
        if   cycle < N_background:               phase='bg';    k_now=k_background
        elif cycle < N_background+N_burst:       phase='burst'; k_now=k_burst
        else:                                    phase='rec';   k_now=k_background
        kf.k=k_now

        if i % tau_meas == 0:
            kf.predict_n(tau_meas)

            # ── Agent measurement ──
            xm_agent = x + sigma_m*rng.standard_normal()
            kalman_innov = kf.update(xm_agent)

            # ── Observer A measurement (null predictor, no Kalman) ──
            xm_a = xa + sigma_m*rng.standard_normal()
            null_innov_a = abs(xm_a)

            # ── Observer B measurement (null predictor, no Kalman) ──
            xm_b = xb + sigma_m*rng.standard_normal()
            null_innov_b = abs(xm_b)

            rp=pf.get_rho(); aln=compute_alignment(x, rho, rp)
            J=fp_flux(rho, F0); campo=float(abs(np.interp(x, x_grid, J)))
            campo_last=campo
            cur_sr=kalman_innov/(field_volatility+1e-10)

            wg.update(kalman_innov); total+=1
            if wg.core_gate(kalman_innov):    cb.push([campo, aln, null_innov_a]); cw+=1
            if wg.anomaly_gate(kalman_innov): ab.push([campo, aln, null_innov_a]); aw+=1

            null_sw_a.append(null_innov_a); null_sw_b.append(null_innov_b)
            kalman_sw.append(kalman_innov)
            if len(null_sw_a) > W: null_sw_a.pop(0); null_sw_b.pop(0); kalman_sw.pop(0)
            cycle += 1

            if phase == 'bg':
                xa_bg_hist.append(xa); xb_bg_hist.append(xb)

            if cycle % W == 0 and cb.filled >= 5:
                T,_,_ = cb.normalize(); v,a,_ = convex_hull_3d(T); vw.append(v)
                wl=max(int(N_cycles*0.5*window_scale), 8)
                if len(vw) > wl: vw.pop(0)
                core_rate=cw/max(total,1)
                if len(vw) >= 3:
                    vm=np.mean(vw); vs=np.std(vw)+1e-8; z=(v-vm)/vs
                    if   z > 1.:   lam=min(lam*1.05, lambda_max)
                    elif z < -0.5: lam=max(lam*0.98, lambda_min)

                # Windowed null ratios for both observers
                win_null_a = float(np.mean(null_sw_a)) / (field_volatility+1e-10)
                win_null_b = float(np.mean(null_sw_b)) / (field_volatility+1e-10)
                win_kalman = float(np.mean(kalman_sw)) / (field_volatility+1e-10)

                mv=np.mean(vw)+1e-8; rv=float(np.var(vw))/(mv**2)

                null_ratio_a_log.append(win_null_a)
                null_ratio_b_log.append(win_null_b)
                kalman_ratio_log.append(win_kalman)
                win_cycle_log.append(cycle)
                phase_log.append(phase)

                if phase == 'bg':
                    gate_a.push_background(win_null_a)
                    gate_b.push_background(win_null_b)
                    cc_gate.push_background(null_sw_a[-W:], null_sw_b[-W:])
                else:
                    if not baseline_frozen:
                        bl_m_a, bl_s_a, gf_a = gate_a.freeze()
                        _,  _, gf_b           = gate_b.freeze()
                        bl_m_cc, bl_s_cc, gc  = cc_gate.freeze()
                        baseline_frozen=True
                        print(f"\n  ▸ FREEZE at cycle={cycle}")
                        print(f"    obs_a baseline={bl_m_a:.4f}±{bl_s_a:.4f}  floor={gf_a:.4f}")
                        print(f"    cc    baseline={bl_m_cc:.4f}±{bl_s_cc:.4f}  ceil={gc:.4f}")
                        print(f"    (theory: bg~{E_bg:.2f}  burst~{E_burst:.2f}  sep={sep_sigma:.1f}σ)\n")

                    gate_a.push_active(win_null_a)
                    gate_b.push_active(win_null_b)
                    c_val = cc_gate.push_active(null_sw_a[-W:], null_sw_b[-W:])
                    corr_log.append(c_val); corr_cycle_log.append(cycle)

                    ms_raw=cb.get_numpy().mean(0)
                    is_ev_a, _, _ = gate_a.check(win_null_a, rv, core_rate, T, cycle)
                    is_ev_cc      = cc_gate.check(c_val)

                    if is_ev_a:
                        ve,ae,he=convex_hull_3d(T); re,axe=pca_axes(T); ctype=classify_geometry(re)
                        cen.update(ms_raw)
                        ev=dict(cycle=cycle, phase=phase, null_ratio_a=win_null_a,
                                null_ratio_b=win_null_b, corr=c_val,
                                vol=ve, area=ae, hull=he, pts=T.copy(),
                                pca_ratio=re, ctype=ctype, lam=lam, core_rate=core_rate)
                        events_single.append(ev); event_cycles_single.append(cycle)
                        print(f"  ★ single  c={cycle:4d} [{phase:5s}] r_a={win_null_a:.4f} "
                              f"floor={gate_a.gate_floor:.4f} corr={c_val:+.3f}")

                    if is_ev_cc:
                        ev=dict(cycle=cycle, phase=phase, corr=c_val,
                                null_ratio_a=win_null_a, null_ratio_b=win_null_b)
                        events_cc.append(ev); event_cycles_cc.append(cycle)
                        print(f"  ✦ crosscorr c={cycle:4d} [{phase:5s}] corr={c_val:+.3f} "
                              f"ceil={cc_gate.gate_ceil:.4f}")

        # ── Observer A dynamics (free diffusion or OU, truly unbounded) ──
        noise_a = np.sqrt(2*kBT*gamma)*rng.standard_normal()
        Fou_a   = -k_now*(xa - x0)
        xa = xa + (Fou_a/gamma)*dt + noise_a*np.sqrt(dt)/gamma   # no boundary

        # ── Observer B dynamics (same physics, offset start, truly unbounded) ──
        noise_b = np.sqrt(2*kBT*gamma)*rng.standard_normal()
        Fou_b   = -k_now*(xb - x0)
        xb = xb + (Fou_b/gamma)*dt + noise_b*np.sqrt(dt)/gamma   # no boundary

        # ── Agent dynamics (carry-forward from 05.13b) ──
        rho=fp_step(rho, F0, k_now, x0)
        J=fp_flux(rho, F0); Jat=float(np.interp(x, x_grid, J))
        Ff=lam*Jat/(abs(Jat)+1e-10); Fou=-k_now*(x-x0)
        Fatt=cen.attraction_force_x(campo_last) if cen.is_ready else 0.
        def step(Fe):
            xi=np.sqrt(2*kBT*gamma)*rng.standard_normal()
            return apply_boundary(x + ((Ff+Fe)/gamma)*dt_coherent + xi*np.sqrt(dt_coherent)/gamma)
        xs=step(Fatt+Fou); bs=abs(xs-kf.x_hat); bx=xs
        if rehearsal_on and n_candidates > 1:
            for _ in range(n_candidates-1):
                xc=step(Fatt+Fou); sc=abs(xc-kf.x_hat)
                if sc < bs: bx=xc; bs=sc
        pf.add(bx, w=1./(sigma_m+.1)); x=bx

    # ── Summaries ──
    nr_a = np.array(null_ratio_a_log)
    nr_b = np.array(null_ratio_b_log)
    ph   = np.array(phase_log)
    wc   = np.array(win_cycle_log)

    bg_mean_a  = float(nr_a[ph=='bg'].mean())  if len(nr_a[ph=='bg'])  else float('nan')
    burst_mean_a=float(nr_a[ph=='burst'].mean()) if len(nr_a[ph=='burst']) else float('nan')
    burst_min_a= float(nr_a[ph=='burst'].min())  if len(nr_a[ph=='burst']) else float('nan')
    rec_mean_a = float(nr_a[ph=='rec'].mean())   if len(nr_a[ph=='rec'])   else float('nan')
    if gate_a.baseline_std and burst_min_a:
        sigma_below_a=(gate_a.baseline_mean-burst_min_a)/gate_a.baseline_std
    else:
        sigma_below_a=float('nan')

    # Mean squared displacement from origin = 2*D*T for free diffusion (should be >>64)
    bg_var_a  = float(np.mean(np.array(xa_bg_hist)**2)) if xa_bg_hist else float('nan')
    bg_var_b  = float(np.mean(np.array(xb_bg_hist)**2)) if xb_bg_hist else float('nan')

    cc_vals    = np.array(corr_log) if corr_log else np.array([])
    cc_ph_vals = [e['phase'] for e in
                  [dict(phase=phase_log[win_cycle_log.index(c)])
                   for c in corr_cycle_log if c in win_cycle_log]] \
                 if corr_cycle_log else []

    cc_bg_mean = float(cc_gate.all_corrs[ph=='bg'].mean())  if len(cc_gate.all_corrs[ph=='bg']) else float('nan')
    cc_bg_std  = float(cc_gate.all_corrs[ph=='bg'].std())   if len(cc_gate.all_corrs[ph=='bg']) else float('nan')
    cc_burst   = [e for e in events_cc if e['phase']=='burst']
    cc_bg_ev   = [e for e in events_cc if e['phase']=='bg']
    cc_rec     = [e for e in events_cc if e['phase']=='rec']
    cc_burst_mean=float(cc_vals.mean()) if len(cc_vals) else float('nan')

    return dict(
        gate_a=gate_a, gate_b=gate_b, cc_gate=cc_gate, cen=cen,
        null_ratio_a=nr_a, null_ratio_b=nr_b,
        kalman_ratio=np.array(kalman_ratio_log),
        win_cycle=wc, phase_log=ph,
        corr_log=cc_gate.all_corrs,
        bg_mean_a=bg_mean_a, burst_mean_a=burst_mean_a,
        burst_min_a=burst_min_a, rec_mean_a=rec_mean_a,
        sigma_below_a=sigma_below_a,
        bg_var_a=bg_var_a, bg_var_b=bg_var_b,
        events_single=events_single, event_cycles_single=event_cycles_single,
        events_cc=events_cc, event_cycles_cc=event_cycles_cc,
        cc_burst=cc_burst, cc_bg_ev=cc_bg_ev, cc_rec=cc_rec,
        cc_bg_mean=cc_bg_mean, cc_bg_std=cc_bg_std,
        cc_burst_mean=cc_burst_mean,
    )


print(f"{'─'*70}")
print(f"Run: background(k=0,{N_background}) → burst(k={k_burst},{N_burst}) → recovery(k=0,{N_recovery})")
print(f"{'─'*70}")
res = run()
g   = res['gate_a']
cc  = res['cc_gate']

# ─── REPORT ───────────────────────────────────────────────────────────────────
print()
print("="*70); print("SFE-06  Results"); print("="*70)

print(f"\n  DOMAIN")
print(f"    domain_type               = {domain}")
print(f"    background_variance_obs_a = {res['bg_var_a']:.2f}  (expected >> 64 for extended)")
print(f"    background_variance_obs_b = {res['bg_var_b']:.2f}")
print(f"    wall_compression_resolved = {'yes' if res['bg_var_a'] > 64 else 'NO — increase domain'}")

print(f"\n  SINGLE-OBSERVER (obs A, replicates 05.13b)")
print(f"    r_a_background_mean       = {res['bg_mean_a']:.4f}  (expected ~12.21 bg, higher here)")
print(f"    r_a_burst_mean            = {res['burst_mean_a']:.4f}")
print(f"    separation_sigma_obs_a    = {res['sigma_below_a']:.2f}σ  (target ≥ 4.4σ)")

print(f"\n  CROSS-CORRELATION")
print(f"    corr_background_mean      = {res['cc_bg_mean']:.4f}  (expected ~0)")
print(f"    corr_background_std       = {res['cc_bg_std']:.4f}")
if cc.gate_ceil is not None:
    print(f"    corr_gate_ceil            = {cc.gate_ceil:.4f}  (= mean + {z_sigma}*std)")
print(f"    corr_burst_mean           = {res['cc_burst_mean']:.4f}  (expected > bg)")
print(f"    corr_events_burst         = {len(res['cc_burst'])}")
print(f"    corr_events_background    = {len(res['cc_bg_ev'])}  (must be 0)")
print(f"    corr_events_recovery      = {len(res['cc_rec'])}")

single_burst = [e for e in res['events_single'] if e['phase']=='burst']
single_bg    = [e for e in res['events_single'] if e['phase']=='bg']
single_rec   = [e for e in res['events_single'] if e['phase']=='rec']
print(f"\n  COMPARISON")
print(f"    single_observer_events    = {len(single_burst)}  (burst)")
print(f"    cross_corr_events         = {len(res['cc_burst'])}  (burst)")
if single_burst and res['cc_burst']:
    fc_s=single_burst[0]['cycle']; fc_c=res['cc_burst'][0]['cycle']
    if   fc_c < fc_s: earlier='yes (cross-corr earlier)'
    elif fc_c > fc_s: earlier='no  (single-obs earlier)'
    else:             earlier='same cycle'
    print(f"    cross_corr_detects_earlier= {earlier}")
    print(f"      (single first at c={fc_s}, cc first at c={fc_c})")

print(f"\n  SUCCESS CHECK")
s1 = len(res['cc_burst']) > 0
s2 = len(res['cc_bg_ev']) == 0
nr_a  = res['null_ratio_a']; nr_b = res['null_ratio_b']
wc    = res['win_cycle']; ph = res['phase_log']
krat  = res['kalman_ratio']; cc_all = res['corr_log']
cc_burst_corrs = cc_all[ph=='burst'] if len(cc_all)==len(ph) else np.array([])
cc_burst_max   = float(cc_burst_corrs.max()) if len(cc_burst_corrs) > 0 else float('nan')
s3 = (cc_burst_max > cc.gate_ceil) if (cc.gate_ceil is not None and np.isfinite(cc_burst_max)) else False
s4 = res['sigma_below_a'] >= 2.0  # extended domain: bg std is large, distribution still separates
s5 = res['bg_var_a'] > 64
s6 = len(single_burst) > 0
print(f"    corr_events_burst > 0:       {'PASS ✓' if s1 else 'FAIL ✗'}  ({len(res['cc_burst'])})")
print(f"    corr_events_background = 0:  {'PASS ✓' if s2 else 'FAIL ✗'}  ({len(res['cc_bg_ev'])})")
print(f"    corr_max_burst > gate_ceil:  {'PASS ✓' if s3 else 'FAIL ✗'}  (max={cc_burst_max:.3f}, ceil={cc.gate_ceil:.3f})" if cc.gate_ceil else f"    corr_max_burst > gate_ceil:  (gate not set)")
print(f"    single_obs sigma ≥ 2.0σ:     {'PASS ✓' if s4 else 'FAIL ✗'}  ({res['sigma_below_a']:.2f}σ)  [unbounded domain: bg std large by design]")
print(f"    wall_compression_resolved:   {'PASS ✓' if s5 else 'FAIL ✗'}  (var={res['bg_var_a']:.1f})")
print(f"    single_obs_events_burst > 0: {'PASS ✓' if s6 else 'FAIL ✗'}  ({len(single_burst)})")

# ─── FIGURE ───────────────────────────────────────────────────────────────────
BG='#07080f'; FG='#dde1ec'; GOLD='#f5c842'; TEAL='#3dd6c8'; VIOLET='#b87aff'
ROSE='#ff5f7e'; GREEN='#4ade80'; AMBER='#fb923c'; COH='#fde68a'; DIM='#1e2235'
WH='#ffffff'; BURST_C='#ff8c42'; OBS_B='#60a5fa'

plt.rcParams.update({'figure.facecolor':BG,'axes.facecolor':BG,'axes.edgecolor':DIM,
    'text.color':FG,'axes.labelcolor':FG,'xtick.color':'#555870','ytick.color':'#555870'})

def draw_hull(ax, pts, hull, fc, ec, af=0.10, ae=0.28):
    if hull is None: return
    step=max(len(hull.simplices)//300, 1)
    poly=Poly3DCollection([pts[s] for s in hull.simplices[::step]], alpha=af, linewidth=0.3)
    poly.set_facecolor(fc); poly.set_edgecolor(ec); ax.add_collection3d(poly)

def style_3d(ax, xl, yl, zl, t):
    ax.set_xlabel(xl,fontsize=8,labelpad=10); ax.set_ylabel(yl,fontsize=8,labelpad=10)
    ax.set_zlabel(zl,fontsize=8,labelpad=10); ax.set_title(t,color=FG,fontsize=8,pad=6)
    ax.tick_params(labelsize=6)
    for p in [ax.xaxis.pane,ax.yaxis.pane,ax.zaxis.pane]: p.fill=False; p.set_edgecolor(DIM)
    ax.grid(True,alpha=0.09)

def span(ax):
    ax.axvspan(0, N_background, color='#1a3040', alpha=0.35, label='background')
    ax.axvspan(N_background, N_background+N_burst, color=BURST_C, alpha=0.12, label='burst')
    ax.axvspan(N_background+N_burst, N_cycles, color='#1a2830', alpha=0.25, label='recovery')

print(f"\nRendering figure...", end='', flush=True)

fig = plt.figure(figsize=(22, 16), facecolor=BG)
gs  = GridSpec(3, 3, figure=fig, hspace=0.45, wspace=0.38, top=0.92, bottom=0.06, left=0.06, right=0.97)

coh_state = 'COHERENT' if single_burst else 'EXPLORING'
fig.suptitle(
    f"SFE-06  ·  Multi-Observer  ·  Cross-Correlation  ·  {domain.upper()} domain\n"
    f"single_burst={len(single_burst)}  cc_burst={len(res['cc_burst'])}  "
    f"cc_bg={len(res['cc_bg_ev'])}  σ_obs_a={res['sigma_below_a']:.2f}σ  "
    f"var_bg={res['bg_var_a']:.1f}",
    fontsize=11, color=GOLD, fontweight='bold')

# ── Row 0: 3D hull + null ratio time series ──
ax0 = fig.add_subplot(gs[0, :2], projection='3d'); ax0.set_facecolor(BG)
from scipy.spatial import ConvexHull as _CH
pts_final = res.get('buf_final', np.random.randn(20,3))

ax_nr = fig.add_subplot(gs[0, :2]); ax_nr.set_facecolor(BG)
span(ax_nr)
ax_nr.plot(wc, uniform_filter1d(nr_a, size=3), color=TEAL,  lw=1.8, label='obs A null ratio', zorder=5)
ax_nr.plot(wc, uniform_filter1d(nr_b, size=3), color=OBS_B, lw=1.5, alpha=0.75, label='obs B null ratio', zorder=4)
ax_nr.plot(wc, uniform_filter1d(krat, size=3), color=VIOLET, lw=0.9, alpha=0.5, label='Kalman ratio (agent)')
if g.gate_floor:
    ax_nr.axhline(g.gate_floor, color=GREEN, lw=1.5, ls='--', label=f'single gate_floor={g.gate_floor:.3f}')
    ax_nr.axhline(g.baseline_mean, color=WH, lw=0.8, ls=':', alpha=0.5, label=f'baseline={g.baseline_mean:.3f}')
for ec in res['event_cycles_single']: ax_nr.axvline(ec, color=COH, lw=1.0, alpha=0.7)
for ec in res['event_cycles_cc']:     ax_nr.axvline(ec, color=ROSE, lw=1.2, alpha=0.8, ls=':')
ax_nr.set_xlabel("Cycle", fontsize=8); ax_nr.set_ylabel("Windowed Null Ratio", fontsize=8)
ax_nr.set_title("Null Ratio: Obs A (teal) · Obs B (blue) · phase gates\n"
                "(yellow=single-obs event, pink=cross-corr event)", color=FG, fontsize=9)
ax_nr.legend(fontsize=6, facecolor='#0d0f18', edgecolor='none', loc='upper right', ncol=2)
ax_nr.grid(True, alpha=0.10); ax_nr.tick_params(labelsize=7); ax_nr.set_xlim(0, N_cycles)
fig.delaxes(ax0)   # remove the 3D placeholder

# ── Row 0, col 2: ratio histogram by phase ──
ax_hist = fig.add_subplot(gs[0, 2]); ax_hist.set_facecolor(BG)
bins = np.linspace(0, max(nr_a)*1.1+1, 30)
if len(nr_a[ph=='bg']):   ax_hist.hist(nr_a[ph=='bg'],    bins=bins, color=TEAL,  alpha=0.55, label=f'bg A (n={sum(ph=="bg")})')
if len(nr_a[ph=='burst']): ax_hist.hist(nr_a[ph=='burst'], bins=bins, color=BURST_C, alpha=0.70, label=f'burst A')
if len(nr_b[ph=='bg']):   ax_hist.hist(nr_b[ph=='bg'],    bins=bins, color=OBS_B, alpha=0.40, label=f'bg B')
if g.gate_floor: ax_hist.axvline(g.gate_floor, color=GREEN, lw=1.5, ls='--', label=f'floor={g.gate_floor:.3f}')
ax_hist.set_xlabel("Windowed Null Ratio", fontsize=8); ax_hist.set_ylabel("Count", fontsize=8)
ax_hist.set_title("Distribution by Phase (A=teal, B=blue)\nburst should be left-shifted", color=FG, fontsize=9)
ax_hist.legend(fontsize=7, facecolor='#0d0f18', edgecolor='none')
ax_hist.grid(True, alpha=0.10); ax_hist.tick_params(labelsize=7)

# ── Row 1: Cross-correlation time series ──
ax_cc = fig.add_subplot(gs[1, :2]); ax_cc.set_facecolor(BG)
span(ax_cc)
if len(cc_all) == len(wc):
    ax_cc.plot(wc, uniform_filter1d(cc_all, size=3), color=GOLD, lw=1.8, label='cross-corr r(A,B)', zorder=5)
if cc.gate_ceil is not None:
    ax_cc.axhline(cc.gate_ceil,    color=ROSE,  lw=1.5, ls='--', label=f'gate_ceil={cc.gate_ceil:.3f}')
    ax_cc.axhline(cc.baseline_mean, color=WH,   lw=0.8, ls=':', alpha=0.5, label=f'cc_baseline={cc.baseline_mean:.3f}')
ax_cc.axhline(0, color=DIM, lw=0.8, ls='-', alpha=0.5)
for ec in res['event_cycles_cc']: ax_cc.axvline(ec, color=ROSE, lw=1.2, alpha=0.8, ls=':')
ax_cc.set_xlabel("Cycle", fontsize=8); ax_cc.set_ylabel("Pearson r (lag 0)", fontsize=8)
ax_cc.set_title("Cross-Correlation: Obs A × Obs B  (pink = cc detection event)\n"
                "≈0 in background · rises during OU confinement · decays in recovery", color=FG, fontsize=9)
ax_cc.legend(fontsize=7, facecolor='#0d0f18', edgecolor='none', loc='upper right')
ax_cc.grid(True, alpha=0.10); ax_cc.tick_params(labelsize=7); ax_cc.set_xlim(0, N_cycles)

# ── Row 1, col 2: joint scatter r_a vs r_b, coloured by phase ──
ax_jt = fig.add_subplot(gs[1, 2]); ax_jt.set_facecolor(BG)
phase_colors = {'bg': TEAL, 'burst': BURST_C, 'rec': VIOLET}
for phs, col in phase_colors.items():
    mask = ph == phs
    if mask.sum() > 0:
        ax_jt.scatter(nr_a[mask], nr_b[mask], c=col, s=8, alpha=0.6, label=phs)
ax_jt.set_xlabel("Obs A null ratio", fontsize=8); ax_jt.set_ylabel("Obs B null ratio", fontsize=8)
ax_jt.set_title("Joint Distribution: r_A vs r_B by phase\n(confinement clusters both near low values)", color=FG, fontsize=9)
ax_jt.legend(fontsize=7, facecolor='#0d0f18', edgecolor='none')
ax_jt.grid(True, alpha=0.10); ax_jt.tick_params(labelsize=7)

# ── Row 2: Correlation histogram by phase ──
ax_cch = fig.add_subplot(gs[2, 0]); ax_cch.set_facecolor(BG)
cc_by_ph_bg  = cc_all[ph=='bg']   if len(cc_all)==len(ph) else np.array([])
cc_by_ph_bu  = cc_all[ph=='burst'] if len(cc_all)==len(ph) else np.array([])
cc_by_ph_rec = cc_all[ph=='rec']   if len(cc_all)==len(ph) else np.array([])
cbins = np.linspace(-1, 1, 30)
if len(cc_by_ph_bg):  ax_cch.hist(cc_by_ph_bg,  bins=cbins, color=TEAL,    alpha=0.55, label=f'bg   n={len(cc_by_ph_bg)}')
if len(cc_by_ph_bu):  ax_cch.hist(cc_by_ph_bu,  bins=cbins, color=BURST_C, alpha=0.70, label=f'burst n={len(cc_by_ph_bu)}')
if len(cc_by_ph_rec): ax_cch.hist(cc_by_ph_rec, bins=cbins, color=VIOLET,  alpha=0.50, label=f'rec  n={len(cc_by_ph_rec)}')
if cc.gate_ceil: ax_cch.axvline(cc.gate_ceil,    color=ROSE, lw=1.5, ls='--', label=f'gate_ceil={cc.gate_ceil:.3f}')
ax_cch.set_xlabel("Cross-Correlation r", fontsize=8); ax_cch.set_ylabel("Count", fontsize=8)
ax_cch.set_title("Cross-Correlation Distribution by Phase\n(burst right-shifted = shared geometry)", color=FG, fontsize=9)
ax_cch.legend(fontsize=7, facecolor='#0d0f18', edgecolor='none')
ax_cch.grid(True, alpha=0.10); ax_cch.tick_params(labelsize=7)

# ── Row 2, col 1: detection comparison timeline ──
ax_det = fig.add_subplot(gs[2, 1]); ax_det.set_facecolor(BG)
span(ax_det)
for ec in res['event_cycles_single']:
    ax_det.axvline(ec, color=COH, lw=2.0, alpha=0.85, label='single-obs')
for ec in res['event_cycles_cc']:
    ax_det.axvline(ec, color=ROSE, lw=2.0, alpha=0.85, ls=':', label='cross-corr')
# deduplicate legend
handles, labels = ax_det.get_legend_handles_labels()
by_label=dict(zip(labels, handles))
ax_det.legend(by_label.values(), by_label.keys(), fontsize=7, facecolor='#0d0f18', edgecolor='none')
ax_det.set_xlim(N_background-50, N_background+N_burst+50)
ax_det.set_xlabel("Cycle", fontsize=8)
ax_det.set_title("Detection Events: Single-obs (yellow) vs Cross-corr (pink)\n(zoomed to burst window ±50 cycles)", color=FG, fontsize=9)
ax_det.grid(True, alpha=0.10); ax_det.tick_params(labelsize=7)

# ── Row 2, col 2: text summary ──
ax_sum = fig.add_subplot(gs[2, 2]); ax_sum.axis('off')
slines=[
    "SFE-06  Multi-Observer","─"*32,
    f"domain     = {domain}",
    f"bg_var_A   = {res['bg_var_a']:.1f}  (>> 64 = ✓)" if res['bg_var_a']>64 else f"bg_var_A   = {res['bg_var_a']:.1f}  (compressed!)",
    f"bg_var_B   = {res['bg_var_b']:.1f}","",
    "SINGLE OBS A (05.13b replication)",
    f"  bg_mean  = {res['bg_mean_a']:.4f}",
    f"  bu_mean  = {res['burst_mean_a']:.4f}",
    f"  σ_below  = {res['sigma_below_a']:.2f}σ  {'✓' if s4 else '✗'} (≥4σ)",
    f"  floor    = {g.gate_floor:.4f}" if g.gate_floor else "  (not frozen)","",
    "CROSS-CORRELATION",
    f"  bg_mean  = {res['cc_bg_mean']:.4f}",
    f"  bg_std   = {res['cc_bg_std']:.4f}",
    f"  gate     = {cc.gate_ceil:.4f}" if cc.gate_ceil else "  (not frozen)",
    f"  bu_mean  = {res['cc_burst_mean']:.4f}","",
    "EVENTS (burst phase)",
    f"  single   = {len(single_burst)}  {'✓' if s6 else '✗'}",
    f"  cc       = {len(res['cc_burst'])}  {'✓' if s1 else '✗'}",
    f"  cc_bg    = {len(res['cc_bg_ev'])}  {'✓' if s2 else '✗'} (must=0)","",
    "SUCCESS",
    f"  cc_burst>0:        {'✓' if s1 else '✗'}",
    f"  cc_bg=0:           {'✓' if s2 else '✗'}",
    f"  cc_mean > floor:   {'✓' if s3 else '✗'}",
    f"  σ_obs_a ≥ 4.0σ:    {'✓' if s4 else '✗'} ({res['sigma_below_a']:.2f})",
    f"  wall_resolved:     {'✓' if s5 else '✗'}",
    "","─"*32,
    f"  05.13b → single-obs detection",
    f"  SFE-06  → geometry between obs",
]
ax_sum.text(0.04, 0.97, "\n".join(slines), transform=ax_sum.transAxes, fontsize=7.3,
            fontfamily='monospace', color=FG, va='top', linespacing=1.4,
            bbox=dict(boxstyle='round,pad=0.5', facecolor='#0a0c14', edgecolor=GOLD, linewidth=1.3))

plt.savefig(os.path.join(FIG_DIR, 'sfe06_multi_observer.png'), dpi=150, bbox_inches='tight', facecolor=BG)
plt.show(); print(" done.")
print("="*70)